// DllHook.cpp : 定义 DLL 应用程序的入口点。
//

#include "stdafx.h"
#include <windows.h>
#include "tchar.h"
#include <stdio.h>
#include <winsock2.h>
#include <Ws2tcpip.h> //引用这个头文件报错，这个头文件是存在的
#include "time.h"
#include "string.h"
#include "iostream"
#include "fstream"
#include "detours.h"
#include "process.h"
#include "Psapi.h"
#include <wincrypt.h>
#include "Objbase.h"
#include "Shlwapi.h"
#include "winbase.h"
#include "wininet.h"
#include "winuser.h"
//#include "FileAPI.h" 
#include "winsvc.h"
#include "tlhelp32.h"
#include "psapi.h"
#include "winnls.h"
#include "winternl.h"
#include "shellapi.h"
#include "winwlx.h"
#include "winreg.h"
#include "Iphlpapi.h"
#include "Wininet.h"
#include "Lmshare.h"
#include <UrlMon.h>
#include <Wincrypt.h>
#include <sstream>
#include "tinyxml.h"
#include <sys/stat.h>
#include <sys/types.h>
#include <shlobj.h>
#include <strsafe.h>
using namespace std;
#pragma comment(lib,"shell32.lib")
#pragma comment (lib, "detours.lib")
//#pragma comment(lib,"Ws2_32.lib")
#pragma comment(lib,"Psapi.lib")
#pragma comment(lib,"ws2_32.lib")
#pragma comment(lib,"crypt32.lib")


#ifdef _MANAGED
#pragma managed(push, off)
#endif
int api[200];
HANDLE hMutex;
string Log[100];
char log_path[255]="C:\\Log\\Log.txt";
int u=0,d=0,i=0;
char strBuffer[256] ={0};//用户名
char hostname[128];//主机名
char spy[6]="00000";//监测层，监测程序代号，监测程序模块
char ProcessName[255];
void GetProcessName(char* szProcessName,int* nLen){
	DWORD dwProcessID = GetCurrentProcessId();  
	HANDLE hProcess=OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ,FALSE,dwProcessID);   
	if(hProcess)  
	{  
		HMODULE hMod;  
		DWORD   dwNeeded;   
		if(EnumProcessModules(hProcess,&hMod,sizeof(hMod),&dwNeeded))  
		{  
			GetModuleBaseNameA(hProcess,hMod,szProcessName,*nLen);  
		}  
		CloseHandle(hProcess);
	}
}
//u表示可以输出的上文日志条数，d表示可以输出的下文日志条数，n表示窗口大小，i是缓冲区的日志标记
//method=0表示写在本地，method=1表示写到数据库,log_path表示日志的路径
//int n=GetPrivateProfileIntA("configure","window_size",10,"C:\\WINDOWS\\system32\\CONFIG.INI");
//int a1=GetPrivateProfileStringA("configure","log_path","C:\\WINDOWS\\system32\\Log\\Log.txt",log_path,sizeof(log_path),"C:\\WINDOWS\\system32\\CONFIG.INI");
//int m=GetPrivateProfileIntA("configure","method",0,"C:\\WINDOWS\\system32\\CONFIG.INI");


typedef int (WSAAPI *MyWSAStartup)( WORD wVersionRequested, LPWSADATA lpWSAData );
typedef HRESULT (WINAPI *MyURLDownloadToFileA)(LPUNKNOWN,LPCSTR,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);
typedef HRESULT (WINAPI *MyURLDownloadToFileW)(LPUNKNOWN,LPCWSTR,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);//zhangyunan

typedef int (WSAAPI *Myrecv)( SOCKET s, char FAR * buf, int len, int flags );
typedef DWORD (WINAPI *MyNetShareEnum)( LMSTR servername, DWORD level, LPBYTE *bufptr, DWORD prefmaxlen, LPDWORD entriesread, LPDWORD totalentries, LPDWORD resume_handle );
typedef BOOL (WINAPI *MyInternetWriteFile)( HINTERNET hFile, LPCVOID lpBuffer, DWORD dwNumberOfBytesToWrite, LPDWORD lpdwNumberOfBytesWritten );
typedef BOOL (WINAPI *MyInternetReadFile)( HINTERNET hFile, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead );
typedef HINTERNET (STDAPICALLTYPE *MyInternetOpenUrlA)( HINTERNET hInternet, LPCSTR lpszUrl, LPCSTR lpszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext );
typedef HINTERNET (STDAPICALLTYPE *MyInternetOpenUrlW)( HINTERNET hInternet, LPCWSTR lpszUrl, LPCWSTR lpszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext );//zhangyunan

typedef /*INTERNETAPI_*/ HINTERNET ( STDAPICALLTYPE *MyInternetOpenA)( LPCSTR lpszAgent, DWORD dwAccessType, LPCSTR lpszProxy, LPCSTR lpszProxyBypass, DWORD dwFlags );
typedef /*INTERNETAPI_*/ HINTERNET ( STDAPICALLTYPE *MyInternetOpenW)( LPCWSTR lpszAgent, DWORD dwAccessType, LPCWSTR lpszProxy, LPCWSTR lpszProxyBypass, DWORD dwFlags );//zhangyunan

typedef unsigned long (WSAAPI *Myinet_addr)( const char FAR * cp );
typedef int (WSAAPI *Mygethostname)( char FAR * name, int namelen );
typedef struct hostent* FAR (WSAAPI *Mygethostbyname)( const char FAR * name );
typedef ULONG (WINAPI *MyGetAdaptersInfo)( PIP_ADAPTER_INFO AdapterInfo, PULONG SizePointer );
typedef int (WSAAPI *Myconnect)( SOCKET s, const struct sockaddr FAR * name, int namelen );
typedef int (WSAAPI *Mybind)( SOCKET s, const struct sockaddr FAR *name, int namelen );
typedef SOCKET (WSAAPI *Myaccept)( SOCKET s, struct sockaddr FAR * addr, int FAR * addrlen );
typedef BOOL (* MyFtpPutFileA)( HINTERNET hConnect, LPCSTR lpszLocalFile, LPCSTR lpszNewRemoteFile, DWORD dwFlags, DWORD_PTR dwContext );
typedef BOOL (* MyFtpPutFileW)( HINTERNET hConnect, LPCWSTR lpszLocalFile, LPCWSTR lpszNewRemoteFile, DWORD dwFlags, DWORD_PTR dwContext );//zhangyunan

typedef int (WSAAPI * MySend)(SOCKET s,const char* buf,int len,int flags);
typedef WINGDIAPI BOOL (WINAPI * MyBitBlt)(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
typedef HCERTSTORE (WINAPI * MyCertOpenSystemStoreA)( HCRYPTPROV hProv, LPCSTR szSubsystemProtocol);//这个函数的第一个参数和VS2012上有区别
typedef HRESULT (* MyCoCreateInstance)(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);
typedef BOOL (WINAPI * MyCryptAcquireContext)(HCRYPTPROV *phProv,LPCSTR pszContainer,LPCSTR pszProvider,DWORD dwProvType,DWORD dwFlags);
typedef HRESULT (STDAPICALLTYPE * MyDllInstall)(BOOL bInstall, PCWSTR pszCmdLine);

typedef HWND (WINAPI *MyFindWindowW)(LPCWSTR lpClassName, LPCWSTR lpWindowName);
typedef UINT (WINAPI *MyMapVirtualKeyW)(UINT uCode, UINT uMapType);

typedef BOOL (WINAPI *MyModule32FirstW)(HANDLE hSnapshot, LPMODULEENTRY32W lpme);
typedef BOOL (WINAPI *MyModule32NextW)(HANDLE hSnapshot, LPMODULEENTRY32W lpme);
typedef BOOL (WINAPI *MyModule32First)(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
typedef BOOL (WINAPI *MyModule32Next)(HANDLE hSnapshot, LPMODULEENTRY32 lpme);


//static LONG (WINAPI *RealRegQueryValueExA)( HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)=RegQueryValueExA;//
//static BOOL (WINAPI *RealModule32Next)( HANDLE hSnapshot, LPMODULEENTRY32 lpme )=Module32Next;
//static BOOL (WINAPI *RealModule32First)( HANDLE hSnapshot, LPMODULEENTRY32 lpme );
//typedef DWORD (WINAPI *MyGetModuleFileNameExW)(HANDLE hProcess, HMODULE hModule, LPWSTR lpFileName, DWORD nSize);
//typedef HMODULE (WINAPI *MyGetModuleHandleW)( LPCWSTR lpModuleName);
//typedef VOID (WINAPI *MyGetStartupInfoW)( LPSTARTUPINFOW lpStartupInfo);
//static HMODULE (WINAPI *RealGetModuleHandleW)( LPCWSTR lpModuleName)=GetModuleHandleW;
//static DWORD (WINAPI *RealGetModuleFileNameExW)( HANDLE hProcess, HMODULE hModule, LPWSTR lpFileName, DWORD nSize)=K32GetModuleFileNameExW;
//static UINT (WINAPI *RealMapVirtualKeyW)( UINT uCode, UINT uMapType)=MapVirtualKeyW;
//static HWND (WINAPI *RealFindWindowW)( LPCWSTR lpClassName, LPCWSTR lpWindowName)=FindWindowW;

//typedef int  HookWriteFile(HANDLE hFile,LPCVOID lpBuffer,DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped );

HMODULE h_ws2_32=GetModuleHandleA("ws2_32.dll");
HMODULE h_gdi32=GetModuleHandleA("GDI32.dll");
HMODULE h_crypt32=GetModuleHandleA("Crypt32.dll");
HMODULE h_ole32=GetModuleHandleA("Ole32.dll");
HMODULE h_advapi32=GetModuleHandleA("Advapi32.dll");
HMODULE h_shlwapi=GetModuleHandleA("shlwapi.dll");
HMODULE h_wininet=GetModuleHandleA("Wininet.dll");
HMODULE h_kernel32=GetModuleHandleA("Kernel32.dll");

int * send_addr =(int *)GetProcAddress(h_ws2_32,"send");
PVOID Realsend=send_addr;
int * bitblt_addr=(int *)GetProcAddress(h_gdi32,"BitBlt");
PVOID RealBitBlt=bitblt_addr;
int * ceropensystemstoreA_addr=(int *)GetProcAddress(h_crypt32,"CertOpenSystemStoreA");
PVOID RealCertOpenSystemStoreA=ceropensystemstoreA_addr;
int * cocreateinstance_addr=(int *)GetProcAddress(h_ole32,"CoCreateInstance");
PVOID RealCoCreateInstance=cocreateinstance_addr;
int * cryptacquirecontext_addr=(int *)GetProcAddress(h_advapi32,"CryptAcquireContext");
PVOID RealCryptAcquireContext=cryptacquirecontext_addr;
int * ftpputfilea_addrA=(int *)GetProcAddress(h_wininet,"FtpPutFileA");//zhangyunan
PVOID RealFtpPutFileA=ftpputfilea_addrA;
int * ftpputfilea_addrW=(int *)GetProcAddress(h_wininet,"FtpPutFileW");//zhangyunan
PVOID RealFtpPutFileW=ftpputfilea_addrW;

int * module32first_addrW=(int *)GetProcAddress(h_kernel32,"Module32FirstW");
PVOID RealModule32FirstW=module32first_addrW;
int * module32next_addrW=(int *)GetProcAddress(h_kernel32,"Module32NextW");
PVOID RealModule32NextW=module32next_addrW;
int * module32first_addr=(int *)GetProcAddress(h_kernel32,"Module32First");
PVOID RealModule32First=module32first_addr;
int * module32next_addr=(int *)GetProcAddress(h_kernel32,"Module32Next");
PVOID RealModule32Next=module32next_addr;

//int * module32next_addrW=(int *)GetProcAddress(h_kernel32,"Module32Next");
//PVOID RealModule32Next=module32next_addrW;

PVOID Realaccept=DetourFindFunction("Ws2_32.dll","accept");
PVOID Realbind=DetourFindFunction("Ws2_32.dll","bind");
PVOID Realconnect=DetourFindFunction("Ws2_32.dll","connect");
PVOID RealGetAdaptersInfo=DetourFindFunction("Iphlpapi.dll","GetAdaptersInfo");
PVOID Realgethostbyname=DetourFindFunction("Ws2_32.dll","gethostbyname");
PVOID Realgethostname=DetourFindFunction("Ws2_32.dll","gethostname");
PVOID Realinet_addr=DetourFindFunction("Ws2_32.dll","inet_addr");
PVOID RealInternetOpenA=DetourFindFunction("Wininet.dll","InternetOpenA");
PVOID RealInternetOpenW=DetourFindFunction("Wininet.dll","InternetOpenW");//zhangyunan

PVOID RealInternetOpenUrlA=DetourFindFunction("Wininet.dll","InternetOpenUrlA");
PVOID RealInternetOpenUrlW=DetourFindFunction("Wininet.dll","InternetOpenUrlW");//zhangyunan

PVOID RealInternetReadFile=DetourFindFunction("Wininet.dll","InternetReadFile");
PVOID RealInternetWriteFile=DetourFindFunction("Wininet.dll","InternetWriteFile");
PVOID RealNetShareEnum=DetourFindFunction("Netapi32.dll","NetShareEnum");
PVOID Realrecv=DetourFindFunction("Ws2_32.dll","recv");
PVOID RealURLDownloadToFileA=DetourFindFunction("urlmon.dll","URLDownloadToFileA");
PVOID RealURLDownloadToFileW=DetourFindFunction("urlmon.dll","URLDownloadToFileW");//zhangyunan

PVOID RealWSAStartup=DetourFindFunction("Ws2_32.dll","WSAStartup");

PVOID RealFindWindowW=DetourFindFunction("User32.dll","FindWindowW");
PVOID RealMapVirtualKeyW=DetourFindFunction("User32.dll","MapVirtualKeyW");


//PVOID RealRegQueryValueExA=DetourFindFunction("Advapi32.dll","RegQueryValueExA");
//PVOID RealRegQueryValueExW=DetourFindFunction("Advapi32.dll","RegQueryValueExW");
//PVOID RealModule32First=DetourFindFunction("Kernel32.dll","Module32First");
//PVOID RealModule32Next=DetourFindFunction("Kernel32.dll","Module32Next");
//PVOID RealGetModuleFileNameExW=DetourFindFunction("Kernel32.dll","GetModuleFileNameExW");
//PVOID RealGetModuleHandleW=DetourFindFunction("Kernel32.dll","GetModuleHandleW");
//PVOID RealGetStartupInfoW=DetourFindFunction("Kernel32.dll","GetStartupInfoW");
// target pointer to un-instrumented API 定位目标函数的指针

char dat[100];
char * GetDate(){
	time_t t=time(NULL);
	SYSTEMTIME sys;
	GetLocalTime(&sys);
	sprintf_s(dat,"%4d%02d%02d",sys.wYear,sys.wMonth,sys.wDay);
	return dat;
}

//生成日志名称
char str[100];
char * LogName()
{
	time_t t=time(NULL);
	SYSTEMTIME sys;
	GetLocalTime( &sys );
	DWORD pid=(DWORD)_getpid();
	sprintf_s(str,"%4d%02d%02d%02d%02d%02d%d.txt",sys.wYear,sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond,sys.wMilliseconds);
	return str;
}

//获取当前时间
char tim[50];
char * LogTime(){
	time_t t=time(NULL);
	SYSTEMTIME sys;
	GetLocalTime(&sys);
	sprintf_s(tim,"%4d-%02d-%02d-%02d-%02d-%02d-%03d:\0",sys.wYear,sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond,sys.wMilliseconds);
	return tim;
}
//ofstream f(log_path,ios::app);
//ofstream f;
//获取进程路径名
TCHAR pathname[MAX_PATH];
char path[MAX_PATH];

CHAR * GetProcessPath(){
	DWORD pid=(DWORD)_getpid();
	HANDLE hProcess=OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ,FALSE,pid);
	GetModuleFileNameExW(hProcess,NULL,pathname,MAX_PATH);
	//wprintf(L"%s",pathname);
	int iLength ;
	iLength = WideCharToMultiByte(CP_ACP, 0, pathname, -1, NULL, 0, NULL, NULL);
	WideCharToMultiByte(CP_ACP, 0, pathname, -1, path, iLength, NULL, NULL);
	return path;
	//return pathname;
}



//FILE * fp=fopen("F:\\WINDOWS\\system32\\Log\\Log1.txt","a");



static BOOL (WINAPI *RealWriteFile)(HANDLE hFile,LPCVOID lpBuffer,DWORD nNumberOfBytesToWrite,LPDWORD lpNumberOfBytesWritten,LPOVERLAPPED lpOverlapped)=WriteFile;
static HFILE (WINAPI *RealOpenFile)( LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle )=OpenFile;
static BOOL (WINAPI *RealConnectNamedPipe)(HANDLE hNamedPipe,LPOVERLAPPED lpOverlapped )=ConnectNamedPipe;
static LONG (WINAPI *RealRegOpenKeyA)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult )=RegOpenKeyA;
static BOOL (WINAPI *RealRegisterHotKey)(HWND hWnd, int id, UINT fsModifiers, UINT vk)=RegisterHotKey;
static BOOL (WINAPI *RealWriteProcessMemory)( HANDLE hProcess , LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T * lpNumberOfBytesWritten )=WriteProcessMemory;
static UINT (WINAPI *RealWinExec)(LPCSTR lpCmdLine, UINT uCmdShow )=WinExec;
static BOOL (WINAPI *RealVirtualProtectEx)( HANDLE hProcess , LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect )=VirtualProtectEx;
static LPVOID (WINAPI *RealVirtualAllocEx)( HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect )=VirtualAllocEx;
static BOOL (WINAPI *RealToolhelp32ReadProcessMemory)( DWORD th32ProcessID, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T cbRead, SIZE_T *lpNumberOfBytesRead )=Toolhelp32ReadProcessMemory;
static BOOL (WINAPI *RealThread32Next)( HANDLE hSnapshot, LPTHREADENTRY32 lpte )=Thread32Next;
static BOOL (WINAPI *RealThread32First)( HANDLE hSnapshot, LPTHREADENTRY32 lpte )=Thread32First;
static int (*Realsystem)(const char * _Command)=system;
static DWORD (WINAPI *RealSuspendThread)(HANDLE hThread )=SuspendThread;
static BOOL (WINAPI *RealStartServiceCtrlDispatcherA)(CONST SERVICE_TABLE_ENTRYA *lpServiceStartTable )=StartServiceCtrlDispatcherA;
static HINSTANCE (WINAPI *RealShellExecuteA)(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd)=ShellExecuteA;
static HHOOK (WINAPI *RealSetWindowsHookExA)(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId)=SetWindowsHookExA;
static BOOL (WINAPI *RealSetThreadContext)( HANDLE hThread,  CONST CONTEXT * lpContext )=SetThreadContext;
static DWORD (WINAPI *RealResumeThread)(  HANDLE hThread )=ResumeThread;
static BOOL (WINAPI *RealReadProcessMemory)(  HANDLE hProcess ,  LPCVOID lpBaseAddress, LPVOID lpBuffer,  SIZE_T nSize,  SIZE_T * lpNumberOfBytesRead )=ReadProcessMemory;
static DWORD (WINAPI *RealQueueUserAPC)(  PAPCFUNC pfnAPC,  HANDLE hThread,  ULONG_PTR dwData )=QueueUserAPC;
static BOOL (WINAPI *RealQueryPerformanceCounter)(  LARGE_INTEGER * lpPerformanceCount )=QueryPerformanceCounter;
static BOOL (WINAPI *RealProcess32First)( HANDLE hSnapshot, LPPROCESSENTRY32 lppe )=Process32First;
static BOOL (WINAPI *RealProcess32Next)( HANDLE hSnapshot, LPPROCESSENTRY32 lppe )=Process32Next;
static BOOL (WINAPI *RealPeekNamedPipe)(  HANDLE hNamedPipe, LPVOID lpBuffer,  DWORD nBufferSize,  LPDWORD lpBytesRead,  LPDWORD lpTotalBytesAvail,  LPDWORD lpBytesLeftThisMessage )=PeekNamedPipe;
static VOID (WINAPI *RealOutputDebugStringA)(  LPCSTR lpOutputString )=OutputDebugStringA;
static HANDLE (WINAPI *RealOpenProcess)(  DWORD dwDesiredAccess,  BOOL bInheritHandle,  DWORD dwProcessId )=OpenProcess;
//static BOOL (WINAPI *RealModule32NextW)( HANDLE hSnapshot, LPMODULEENTRY32W lpme )=Module32NextW;
//static BOOL (WINAPI *RealModule32FirstW)( HANDLE hSnapshot, LPMODULEENTRY32W lpme )=Module32FirstW;
static HGLOBAL (WINAPI *RealLoadResource)(  HMODULE hModule,  HRSRC hResInfo )=LoadResource;
static HMODULE (WINAPI *RealLoadLibraryA)(  LPCSTR lpLibFileName )=LoadLibraryA;
static BOOL (WINAPI *RealIsDebuggerPresent)(VOID)=IsDebuggerPresent;
static BOOL (WINAPI *RealGetVersionExA)(  LPOSVERSIONINFOA lpVersionInformation )= GetVersionExA;
static DWORD (WINAPI *RealGetTickCount)(VOID)=GetTickCount;
static BOOL (WINAPI *RealGetThreadContext)(  HANDLE hThread,  LPCONTEXT lpContext )=GetThreadContext;
static LANGID (WINAPI *RealGetSystemDefaultLangID)(void)=GetSystemDefaultLangID;
static void(WINAPI *RealGetStartupInfoA)(  LPSTARTUPINFOA lpStartupInfo )=GetStartupInfoA;
static FARPROC (WINAPI *RealGetProcAddress)(  HMODULE hModule,  LPCSTR lpProcName )=GetProcAddress;
static HMODULE (WINAPI *RealGetModuleHandleA)(  LPCSTR lpModuleName )=GetModuleHandleA;
static DWORD (WINAPI *RealGetModuleFileNameExA)(  HANDLE hProcess,  HMODULE hModule, LPSTR lpFilename,  DWORD nSize )=GetModuleFileNameExA;
static BOOL (WINAPI *RealEnumProcessModules)(  HANDLE hProcess, HMODULE *lphModule,  DWORD cb,  LPDWORD lpcbNeeded )=EnumProcessModules;
static BOOL (WINAPI *RealEnumProcesses)( DWORD * lpidProcess,  DWORD cb,  LPDWORD lpcbNeeded )=EnumProcesses;
static HANDLE (WINAPI *RealCreateToolhelp32Snapshot)( DWORD dwFlags, DWORD th32ProcessID )=CreateToolhelp32Snapshot;
static SC_HANDLE (WINAPI *RealCreateServiceA)(  SC_HANDLE hSCManager,  LPCSTR lpServiceName,  LPCSTR lpDisplayName,  DWORD dwDesiredAccess,  DWORD dwServiceType,  DWORD dwStartType,  DWORD dwErrorControl,  LPCSTR lpBinaryPathName,  LPCSTR lpLoadOrderGroup,  LPDWORD lpdwTagId,  LPCSTR lpDependencies,  LPCSTR lpServiceStartName,  LPCSTR lpPassword )=CreateServiceA;
static HANDLE (WINAPI *RealCreateRemoteThread)(  HANDLE hProcess,  LPSECURITY_ATTRIBUTES lpThreadAttributes,  SIZE_T dwStackSize,  LPTHREAD_START_ROUTINE lpStartAddress,  LPVOID lpParameter,  DWORD dwCreationFlags,  LPDWORD lpThreadId )=CreateRemoteThread;
static BOOL (WINAPI *RealCreateProcessA)(  LPCSTR lpApplicationName, LPSTR lpCommandLine,  LPSECURITY_ATTRIBUTES lpProcessAttributes,  LPSECURITY_ATTRIBUTES lpThreadAttributes,  BOOL bInheritHandles,  DWORD dwCreationFlags,  LPVOID lpEnvironment,  LPCSTR lpCurrentDirectory,  LPSTARTUPINFOA lpStartupInfo,  LPPROCESS_INFORMATION lpProcessInformation )=CreateProcessA;
static BOOL (WINAPI *RealControlService)(  SC_HANDLE hService,  DWORD dwControl,  LPSERVICE_STATUS lpServiceStatus )=ControlService;
static BOOL (WINAPI *RealCheckRemoteDebuggerPresent)(  HANDLE hProcess,  PBOOL pbDebuggerPresent )=CheckRemoteDebuggerPresent;
static LRESULT (WINAPI *RealCallNextHookEx)( HHOOK hhk,  int nCode,  WPARAM wParam,  LPARAM lParam)=CallNextHookEx;
static BOOL (WINAPI *RealAttachThreadInput)( DWORD idAttach,  DWORD idAttachTo,  BOOL fAttach)=AttachThreadInput;
static BOOL (WINAPI *RealAdjustTokenPrivileges)(  HANDLE TokenHandle,  BOOL DisableAllPrivileges,  PTOKEN_PRIVILEGES NewState,  DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState,  PDWORD ReturnLength )=AdjustTokenPrivileges;
static SC_HANDLE (WINAPI *RealOpenSCManagerA)(  LPCSTR lpMachineName,  LPCSTR lpDatabaseName,  DWORD dwDesiredAccess )=OpenSCManagerA;
static UINT (WINAPI *RealMapVirtualKeyA)( UINT uCode,  UINT uMapType)=MapVirtualKeyA;
static LPVOID (WINAPI *RealMapViewOfFile)(  HANDLE hFileMappingObject,  DWORD dwDesiredAccess,  DWORD dwFileOffsetHigh,  DWORD dwFileOffsetLow,  SIZE_T dwNumberOfBytesToMap)=MapViewOfFile;
static BOOL (WINAPI *RealSetFileTime)(  HANDLE hFile,  CONST FILETIME * lpCreationTime,  CONST FILETIME * lpLastAccessTime,  CONST FILETIME * lpLastWriteTime )=SetFileTime;
static HANDLE (WINAPI *RealOpenMutexA)(  DWORD dwDesiredAccess,  BOOL bInheritHandle,  LPCSTR lpName )=OpenMutexA;
static UINT (WINAPI *RealGetWindowsDirectoryA)(  LPSTR lpBuffer,   UINT uSize)=GetWindowsDirectoryA;
static DWORD (WINAPI *RealGetTempPath)( DWORD nBufferLength, LPWSTR lpBuffer )=GetTempPathW;
static SHORT (WINAPI *RealGetKeyState)( int nVirtKey)=GetKeyState;
static HWND (WINAPI *RealGetForegroundWindow)()=GetForegroundWindow;
static HDC (WINAPI *RealGetDC)( HWND hWnd)=GetDC;
static SHORT (WINAPI *RealGetAsyncKeyState)( int vKey)=GetAsyncKeyState;
static HWND (WINAPI *RealFindWindowA)( LPCSTR lpClassName,  LPCSTR lpWindowName)=FindWindowA;
static HRSRC (WINAPI *RealFindResourceA)(  HMODULE hModule,  LPCSTR lpName,  LPCSTR lpType )=FindResourceA;
static BOOL (WINAPI *RealFindNextFileA)(  HANDLE hFindFile,  LPWIN32_FIND_DATAA lpFindFileData)=FindNextFileA;
static HANDLE (WINAPI *RealFindFirstFileA)(  LPCSTR lpFileName,  LPWIN32_FIND_DATAA lpFindFileData )=FindFirstFileA;
static BOOL (WINAPI *RealDeviceIoControl)(  HANDLE hDevice,  DWORD dwIoControlCode, LPVOID lpInBuffer,  DWORD nInBufferSize, LPVOID lpOutBuffer,  DWORD nOutBufferSize,  LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped )=DeviceIoControl;
static BOOL (WINAPI *RealReadFile)(  HANDLE hFile,  LPVOID lpBuffer,  DWORD nNumberOfBytesToRead,  LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped )=ReadFile;
static HANDLE (WINAPI *RealCreateFile)(LPCTSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE)=CreateFile;
static HANDLE (WINAPI *RealCreateMutexA)( LPSECURITY_ATTRIBUTES lpMutexAttributes,  BOOL bInitialOwner,  LPCSTR lpName )=CreateMutexA;
static HANDLE (WINAPI *RealCreateFileMapping)(HANDLE,LPSECURITY_ATTRIBUTES,DWORD,DWORD,DWORD,LPCTSTR)=CreateFileMapping;
static BOOL (WINAPI *RealDeleteFile)( LPCTSTR lpFileName)=DeleteFile;
static BOOL (WINAPI *RealDeleteFileA)(LPCSTR) = DeleteFileA;
static BOOL (WINAPI *RealCopyFileA)(LPCSTR,LPCSTR,BOOL)=CopyFileA;
static BOOL (WINAPI *RealMoveFileA)(LPCSTR,LPCSTR)=MoveFileA;
static HANDLE (WINAPI *RealCreateFileA)(LPCSTR,DWORD,DWORD,LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE)=CreateFileA;
static LONG (WINAPI *RealRegOpenKeyEx)(	HKEY hKey,LPCWSTR lpSubKey,	DWORD ulOptions,	REGSAM samDesired,	PHKEY phkResult	)=RegOpenKeyExW;

//zhangyunan.
static HANDLE (WINAPI *RealCreateFileW)( LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)=CreateFileW;//暂时hook不成功，ofstream创建对象时出现问题。
static BOOL (WINAPI *RealMoveFileW)( LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)=MoveFileW;
static BOOL (WINAPI *RealCopyFileW)( LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)=CopyFileW;
static BOOL (WINAPI *RealDeleteFileW)( LPCWSTR lpFileName) = DeleteFileW;
static HANDLE (WINAPI *RealFindFirstFileW)( LPCWSTR,  LPWIN32_FIND_DATAW)=FindFirstFileW;
static BOOL (WINAPI *RealFindNextFileW)( HANDLE hFindFile,  LPWIN32_FIND_DATAW lpFindFileData)=FindNextFileW;
static HCERTSTORE (WINAPI *RealCertOpenSystemStoreW)( HCRYPTPROV_LEGACY hProv,  LPCWSTR szSubsystemProtocol)=CertOpenSystemStoreW;
static HANDLE (WINAPI *RealCreateMutexW)( LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)=CreateMutexW;
static HRSRC (WINAPI *RealFindResourceW)( HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)=FindResourceW;
static UINT (WINAPI *RealGetWindowsDirectoryW)( LPWSTR lpBuffer, UINT uSize)=GetWindowsDirectoryW;
//static UINT (WINAPI *RealMapVirtualKeyW)( UINT uCode, UINT uMapType)=MapVirtualKeyW;
static HANDLE (WINAPI *RealOpenMutexW)( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)=OpenMutexW;
static SC_HANDLE (WINAPI *RealOpenSCManagerW)( LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess)=OpenSCManagerW;
//static BOOL (WINAPI *RealCreateProcessW)( LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)=CreateProcessW;
static SC_HANDLE (WINAPI *RealCreateServiceW)( SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPCWSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword)=CreateServiceW;
static DWORD (WINAPI *RealGetModuleFileNameExW)( HANDLE hProcess, HMODULE hModule, LPWSTR lpFileName, DWORD nSize)=GetModuleFileNameExW;//K32GetModuleFileNameExW;
static HMODULE (WINAPI *RealGetModuleHandleW)( LPCWSTR lpModuleName)=GetModuleHandleW;
static VOID (WINAPI *RealGetStartupInfoW)( LPSTARTUPINFOW lpStartupInfo)=GetStartupInfoW;
static BOOL (WINAPI *RealGetVersionExW)( LPOSVERSIONINFOW lpVersionInfo)=GetVersionExW;
static HMODULE (WINAPI *RealLoadLibraryW)( LPCWSTR lpFileName)=LoadLibraryW;
static VOID (WINAPI *RealOutputDebugStringW)( LPCWSTR lpOutputString)=OutputDebugStringW;
static HHOOK (WINAPI *RealSetWindowsHookExW)( int idHook, HOOKPROC lpfn, HINSTANCE hMod, DWORD dwThreadId)=SetWindowsHookExW;
static HINSTANCE (WINAPI *RealShellExecuteW)( HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd)=ShellExecuteW;
static BOOL (WINAPI *RealStartServiceCtrlDispatcherW)( CONST SERVICE_TABLE_ENTRYW *lpServiceTable)=StartServiceCtrlDispatcherW;
static LONG (WINAPI *RealRegOpenKeyW)( HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)=RegOpenKeyW;
//static BOOL (WINAPI *RealModule32Next)( HANDLE hSnapshot, LPMODULEENTRY32 lpme )=Module32Next;
//static BOOL (WINAPI *RealModule32First)( HANDLE hSnapshot, LPMODULEENTRY32 lpme )=Module32First;
static LONG (WINAPI *RealRegCreateKeyExA)( HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)=RegCreateKeyExA;
static LONG (WINAPI *RealRegCreateKeyExW)( HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)=RegCreateKeyExW;
static LONG (WINAPI *RealRegCreateKeyA)( HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)=RegCreateKeyA;
static LONG (WINAPI *RealRegCreateKeyW)( HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)=RegCreateKeyW;
static LONG (WINAPI *RealRegQueryValueExA)( HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)=RegQueryValueExA;
static LONG (WINAPI *RealRegQueryValueExW)( HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)=RegQueryValueExW;
static LONG (WINAPI *RealRegQueryValueA)( HKEY hKey, LPCSTR lpSubKey, LPSTR lpValue, PLONG lpcbValue)=RegQueryValueA;
static LONG (WINAPI *RealRegQueryValueW)( HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpValue, PLONG lpcbValue)=RegQueryValueW;
static LONG (WINAPI *RealRegSetValueExA)( HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)=RegSetValueExA;
static LONG (WINAPI *RealRegSetValueExW)( HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)=RegSetValueExW;
static LONG (WINAPI *RealRegSetValueA)( HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData)=RegSetValueA;
static LONG (WINAPI *RealRegSetValueW)( HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData)=RegSetValueW;
static LONG (WINAPI *RealRegDeleteKeyExA)( HKEY hKey, LPCSTR lpSubKey,REGSAM samDesired, DWORD Reserved)=RegDeleteKeyExA;
static LONG (WINAPI *RealRegDeleteKeyExW)( HKEY hKey, LPCWSTR lpSubKey,REGSAM samDesired, DWORD Reserved)=RegDeleteKeyExW;
static LONG (WINAPI *RealRegDeleteKeyA)( HKEY hKey, LPCSTR lpSubKey)=RegDeleteKeyA;
static LONG (WINAPI *RealRegDeleteKeyW)( HKEY hKey, LPCWSTR lpSubKey)=RegDeleteKeyW;

//int GetFileNameByHandle(HANDLE hFile,LPTSTR buff,DWORD size);
typedef DWORD (WINAPI *MyGetMappedFileName)(HANDLE,LPVOID,LPTSTR,DWORD);

//CHAR * GetProcessPath(){
//	DWORD pid=(DWORD)_getpid();
//	HANDLE hProcess=OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ,FALSE,pid);
//	//GetModuleFileNameExW(hProcess,NULL,pathname,MAX_PATH);
//	RealGetModuleFileNameExW(hProcess,NULL,pathname,MAX_PATH);
//	//printf("GetModuleAddress is 0x%x  && RealGetModuleFileNameExW is 0x%x \n:",GetModuleFileNameEx,RealGetModuleFileNameExW);
//	//wprintf(L"%s",pathname);
//	int iLength ;
//	iLength = WideCharToMultiByte(CP_ACP, 0, pathname, -1, NULL, 0, NULL, NULL);
//	WideCharToMultiByte(CP_ACP, 0, pathname, -1, path, iLength, NULL, NULL);
//	return path;
//	//return pathname;
//}
	

//static int (WSAAPI *RealSend)( SOCKET,const char *,int,int)=send;
//static UINT (WINAPI *RealWinExec)(LPCSTR, UINT) = WinExec;
static BOOL (WINAPI *RealCreateProcessW)(
	LPCWSTR, LPWSTR,
	LPSECURITY_ATTRIBUTES,
	LPSECURITY_ATTRIBUTES,
	BOOL, DWORD, LPVOID, LPCWSTR,
	LPSTARTUPINFOW,
	LPPROCESS_INFORMATION) = CreateProcessW;

/*
文件相关API
*/

#define BUFSIZE 512
TCHAR* GetFileNameFromHandle(HANDLE hFile) 
{
	BOOL bSuccess = FALSE;
	TCHAR pszFilename[MAX_PATH+1];
	HANDLE hFileMap;

	// Get the file size.
	DWORD dwFileSizeHi = 0;
	DWORD dwFileSizeLo = GetFileSize(hFile, &dwFileSizeHi); 

	if( dwFileSizeLo == 0 && dwFileSizeHi == 0 )
	{
		//_tprintf(TEXT("Cannot map a file with a length of zero.\n"));
		return FALSE;
	}

	// Create a file mapping object.
	hFileMap = RealCreateFileMapping(hFile, 
		NULL, 
		PAGE_READONLY,
		0, 
		1,
		NULL);

	if (hFileMap) 
	{
		// Create a file mapping to get the file name.
		void* pMem = RealMapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 1);

		if (pMem) 
		{
			if (GetMappedFileName (GetCurrentProcess(), 
				pMem, 
				pszFilename,
				MAX_PATH)) 
			{

				// Translate path with device name to drive letters.
				TCHAR szTemp[BUFSIZE];
				szTemp[0] = '\0';

				if (GetLogicalDriveStrings(BUFSIZE-1, szTemp)) 
				{
					TCHAR szName[MAX_PATH];
					TCHAR szDrive[3] = TEXT(" :");
					BOOL bFound = FALSE;
					TCHAR* p = szTemp;

					do 
					{
						// Copy the drive letter to the template string
						*szDrive = *p;

						// Look up each device name
						if (QueryDosDevice(szDrive, szName, MAX_PATH))
						{
							size_t uNameLen = _tcslen(szName);

							if (uNameLen < MAX_PATH) 
							{
								bFound = _tcsnicmp(pszFilename, szName, uNameLen) == 0
									&& *(pszFilename + uNameLen) == _T('\\');

								if (bFound) 
								{
									// Reconstruct pszFilename using szTempFile
									// Replace device path with DOS path
									TCHAR szTempFile[MAX_PATH];
									StringCchPrintf(szTempFile,
										MAX_PATH,
										TEXT("%s%s"),
										szDrive,
										pszFilename+uNameLen);
									StringCchCopyN(pszFilename, MAX_PATH+1, szTempFile, _tcslen(szTempFile));
								}
							}
						}

						// Go to the next NULL character.
						while (*p++);
					} while (!bFound && *p); // end of string
				}
			}
			bSuccess = TRUE;
			UnmapViewOfFile(pMem);
		} 

		CloseHandle(hFileMap);
	}
	//cout<<pszFilename<<endl;
	/*
	FILE *fp;
	fp=fopen("C:\\Log\\test.txt","a+");
	fputs("aa",fp);
	fclose(fp);
	*/
	//wprintf(L"%s",pszFilename);
	//char hello[1000];
	//TcharToChar(pszFilename,hello);
	//cout<<hello<<endl;
	//_tprintf(TEXT("File name is %s\n"), pszFilename);
	//OutputDebugStringW(pszFilename);
	return pszFilename;
	//return(bSuccess);
}

void TcharToChar (const TCHAR * tchar, char * _char)  
{  
	int iLength ;  
	//获取字节长度   
	iLength = WideCharToMultiByte(CP_ACP, 0, tchar, -1, NULL, 0, NULL, NULL);  
	//将tchar值赋给_char    
	WideCharToMultiByte(CP_ACP, 0, tchar, -1, _char, iLength, NULL, NULL);   
}  

BOOL WINAPI HookWriteFile(HANDLE hFile,LPCVOID lpBuffer,DWORD nNumberOfBytesToWrite,LPDWORD lpNumberOfBytesWritten,LPOVERLAPPED lpOverlapped){
	stringstream logstream;
	logstream.clear();
	CHAR filepath[1000]="NULL";
	//TCHAR filepath1[MAX_PATH+1]=L"NULL";
	TCHAR *filepath1=GetFileNameFromHandle(hFile);
	TcharToChar(filepath1,filepath);
	//OutputDebugStringW(filepath1);
	

	/*
	if(hFile!=NULL){
		GetFileNameByHandle(hFile,filepath,MAX_PATH);
	}
	*/
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<WriteFile>,func_params=<hFile|"<<filepath<<",nNumberOfBytesToWrite|"<<nNumberOfBytesToWrite<<">";
	
	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	//RealOutputDebugStringA(sm.c_str());
	FILE *fp;
	HANDLE h;
	//h=RealCreateFileA("C:\\Log\\a.txt", GENERIC_READ, FILE_SHARE_READ, NULL,OPEN_EXISTING, 0, NULL);
	//RealOutputDebugStringA(sm.c_str());
	DWORD dwSize=0;
	char *logstr="Log.txt";
	//RealWriteFile(h,sm.c_str(),strlen(sm.c_str()),&dwSize,NULL);
	
	
	if(strstr(filepath,logstr)==NULL){
		
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		DetourDetach(&(PVOID&)RealWriteFile,HookWriteFile);
		DetourTransactionCommit();
		
		RealOutputDebugStringA(sm.c_str());
		fp=fopen(log_path,"a+");
		fwrite("aa",2,1,fp);
		fputs(sm.c_str(),fp);
		fclose(fp);
		
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		DetourAttach(&(PVOID&)RealWriteFile,HookWriteFile);
		DetourTransactionCommit();
		
	}
	
	sm="";
	logstream.clear();
	return RealWriteFile(hFile,lpBuffer,nNumberOfBytesToWrite,lpNumberOfBytesWritten,lpOverlapped);
}

BOOL HookBitBlt( HDC hdc,  int x,  int y,  int cx,  int cy,  HDC hdcSrc,  int x1,  int y1,  DWORD rop)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<BitBlt>,func_params=<x|"<<x<<",y|"<<y<<",cx|"<<cx<<",cy|"<<cy<<">";
	string s,sm;
	/*
	logstream>>s;
	sm=s;
	while (1)
	{
		logstream>>s;
		if (logstream==NULL)
		{
			break;
		}
		sm=sm+" "+s;
	}//获取日志记录写入数组
	*/
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
    return ((MyBitBlt)RealBitBlt)(hdc,x,y,cx,cy,hdcSrc,x1,y1,rop);
}
HCERTSTORE WINAPI  HookCertOpenSystemStoreA( HCRYPTPROV hProv,  LPCSTR szSubsystemProtocol)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CertOpenSystemStore>,func_params=<szSubsystemProtocol|"<<szSubsystemProtocol<<">";
	string s,sm;
	sm="";
	/*
	logstream>>s;
	sm=s;
	while (1)
	{
		logstream>>s;
		if (logstream==NULL)
		{
			break;
		}
		sm=sm+" "+s;
	}//获取日志记录写入数组
	*/
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	return ((MyCertOpenSystemStoreA)RealCertOpenSystemStoreA)(hProv,szSubsystemProtocol);
}
HRESULT HookCoCreateInstance( REFCLSID rclsid,  LPUNKNOWN pUnkOuter,  DWORD dwClsContext,  REFIID riid, LPVOID FAR* ppv)
{
	//WaitForSingleObject(hMutex,INFINITE);
	char d[12];
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CoCreateInstance>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MyCoCreateInstance)RealCoCreateInstance)(rclsid,pUnkOuter,dwClsContext,riid,ppv);
}
HANDLE HookCreateFile(LPCTSTR lpFileName,DWORD dwDesiredAccess,DWORD dwShareMode,LPSECURITY_ATTRIBUTES lpSecurityAttributes,DWORD dwCreationDisposition,DWORD dwFlagsAndAttributes,HANDLE hTemplateFile)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CreateFile>,func_params=<lpFileName|"<<lpFileName<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealCreateFile(lpFileName,dwDesiredAccess,dwShareMode,lpSecurityAttributes,dwCreationDisposition,dwFlagsAndAttributes,hTemplateFile);
}
HANDLE WINAPI HookCreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes,BOOL bInitialOwner,LPCSTR lpName)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CreateMutexA>,func_params=<lpName|"<<lpName<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealCreateMutexA(lpMutexAttributes,bInitialOwner,lpName);
}
HANDLE WINAPI HookCreateFileMapping(HANDLE hFile,LPSECURITY_ATTRIBUTES lpAttributes,DWORD flProtect,DWORD dwMaximumSizeHigh,DWORD dwMaximumSizeLow,LPCTSTR lpName)
{
	//WaitForSingleObject(hMutex,INFINITE);
	//GetFileNameFromHandle(hFile);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CreateFileMapping>,func_params=<lpName|"<<lpName<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealCreateFileMapping(hFile,lpAttributes,flProtect,dwMaximumSizeHigh,dwMaximumSizeLow,lpName);
}

BOOL WINAPI HookCryptAcquireContext( HCRYPTPROV *phProv, LPCSTR pszContainer, LPCSTR pszProvider, DWORD dwProvType, DWORD dwFlags ){
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">, proc_func_name=<CryptAcquireContext>,func_params=<pszContainer|"<<(pszContainer==NULL?"NULL":pszContainer)<<",pszProvider|"<<(pszProvider==NULL?"NULL":pszProvider)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MyCryptAcquireContext)RealCryptAcquireContext)(phProv,pszContainer,pszProvider,dwProvType,dwFlags);
}
BOOL HookDeleteFile(LPCTSTR lpFileName)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<DeleteFile>,func_params=<lpFileName|"<<lpFileName<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealDeleteFile(lpFileName);
}
HANDLE WINAPI HookCreateFileA(LPCSTR lpFileName,DWORD dwDesiredAccess,DWORD dwSharedAccess,LPSECURITY_ATTRIBUTES lpSecurityAttributes,DWORD dwCreationDisposition,DWORD dwFlagsAndAttributes,HANDLE hTemplateFile)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CreateFileA>,func_params=<lpFileName|"<<lpFileName<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealCreateFileA(lpFileName,dwDesiredAccess,dwSharedAccess,lpSecurityAttributes,dwCreationDisposition,dwFlagsAndAttributes,hTemplateFile);
}
BOOL WINAPI HookMoveFileA(LPCSTR lpExistingFileName,LPCSTR lpNewFileName){
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<MoveFileA>,func_params=<lpExistingFileName|"<<lpExistingFileName<<",lpNewFileName|"<<lpNewFileName<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealMoveFileA(lpExistingFileName,lpNewFileName);
}
BOOL WINAPI HookCopyFileA(LPCSTR lpExistingFileName,LPCSTR lpNewFileName,BOOL bFailIfExists)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CopyFileA>,func_params=<lpExistingFileName|"<<lpExistingFileName<<",lpNewFileName|"<<lpNewFileName<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealCopyFileA(lpExistingFileName,lpNewFileName,bFailIfExists);
}
BOOL WINAPI HookDeleteFileA(LPCSTR lpFileName)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<DeleteFileA>,func_params=<lpFileName|"<<lpFileName<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealDeleteFileA(lpFileName);
}
BOOL WINAPI HookReadFile( HANDLE hFile, LPVOID lpBuffer,  DWORD nNumberOfBytesToRead,  LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">, proc_func_name=<ReadFile>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealReadFile(hFile,lpBuffer,nNumberOfBytesToRead,lpNumberOfBytesRead,lpOverlapped);
}
BOOL WINAPI HookDeviceIoControl(  HANDLE hDevice,  DWORD dwIoControlCode, LPVOID lpInBuffer,  DWORD nInBufferSize,  LPVOID lpOutBuffer,  DWORD nOutBufferSize,  LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<DeviceIOControl>,func_params=<dwIoControlCode|"<<dwIoControlCode<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealDeviceIoControl(hDevice,dwIoControlCode,lpInBuffer,nInBufferSize,lpOutBuffer,nOutBufferSize,lpBytesReturned,lpOverlapped);
}
HANDLE WINAPI HookFindFirstFileA(  LPCSTR lpFileName,  LPWIN32_FIND_DATAA lpFindFileData )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<FindFirstFileA>,func_params=<lpFileName|"<<lpFileName<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealFindFirstFileA(lpFileName,lpFindFileData);
}
BOOL WINAPI HookFindNextFileA(  HANDLE hFindFile,  LPWIN32_FIND_DATAA lpFindFileData )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<FindNextFileA>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealFindNextFileA(hFindFile,lpFindFileData);
}
HRSRC WINAPI HookFindResourceA(  HMODULE hModule,  LPCSTR lpName,  LPCSTR lpType )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<FindResourceA>,func_params=<lpName|"<<(lpName==NULL?"NULL":lpName)<<",lpType|"<<(lpType==NULL?"NULL":lpType)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealFindResourceA(hModule,lpName,lpType);
}
HWND WINAPI HookFindWindowA( LPCSTR lpClassName,  LPCSTR lpWindowName)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<FindWindowA>,func_params=<lpClassName|"<<lpClassName<<",lpWindowName|"<<lpWindowName<<">";
	
	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealFindWindowA(lpClassName,lpWindowName);
}
BOOL HookFtpPutFileA(  HINTERNET hConnect,  LPCSTR lpszLocalFile,  LPCSTR lpszNewRemoteFile,  DWORD dwFlags,  DWORD_PTR dwContext )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<FtpPutFileA>,func_params=<lpszLocalFile|"<<(lpszLocalFile==NULL?"NULL":lpszLocalFile)<<",lpszNewRemoteFile|"<<(lpszNewRemoteFile==NULL?"NULL":lpszNewRemoteFile)<<">";

	string s,sm;
	sm="";
	
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MyFtpPutFileA)RealFtpPutFileA)(hConnect,lpszLocalFile,lpszNewRemoteFile,dwFlags,dwContext);
}

//by zhangyunan this func
BOOL HookFtpPutFileW(  HINTERNET hConnect,  LPCWSTR lpszLocalFile,  LPCWSTR lpszNewRemoteFile,  DWORD dwFlags,  DWORD_PTR dwContext )
{
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<FtpPutFileW>,func_params=<lpszLocalFile|"<<(lpszLocalFile==NULL?L"NULL":lpszLocalFile)<<",lpszNewRemoteFile|"<<(lpszNewRemoteFile==NULL?L"NULL":lpszNewRemoteFile)<<">";

	string s,sm;
	sm="";
	
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MyFtpPutFileW)RealFtpPutFileW)(hConnect,lpszLocalFile,lpszNewRemoteFile,dwFlags,dwContext);
}
SHORT WINAPI HookGetAsyncKeyState( int vKey)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetAsyncKeyState>,func_params=<vKey|"<<vKey<<">";
	
	string s,sm;
	sm="";
	
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealGetAsyncKeyState(vKey);
}
HDC HookGetDC( HWND hWnd)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetDC>";

	string s,sm;
	sm="";
	
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealGetDC(hWnd);
}
HWND WINAPI HookGetForegroundWindow()
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetForegroundWindow>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealGetForegroundWindow();
}
SHORT WINAPI HookGetKeyState( int nVirtKey)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetKeyState>,func_params=<nVirtKey|"<<nVirtKey<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealGetKeyState(nVirtKey);
}
DWORD WINAPI HookGetTempPath(  DWORD nBufferLength, LPWSTR lpBuffer )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetTempPath>,func_params=<nBufferLength|"<<nBufferLength<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealGetTempPath(nBufferLength,lpBuffer);
}
UINT WINAPI HookGetWindowsDirectoryA(  LPSTR lpBuffer,   UINT uSize)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	//logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetWindowsDirectoryA>,func_params=<lpBuffer|"<<(lpBuffer==NULL?"NULL":lpBuffer)<<",uSize|"<<uSize<<">";
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetWindowsDirectoryA>,func_params=<uSize|"<<uSize<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealGetWindowsDirectoryA(lpBuffer,uSize);
}
HFILE WINAPI HookOpenFile(  LPCSTR lpFileName,  LPOFSTRUCT lpReOpenBuff,  UINT uStyle )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<OpenFile>,func_params=<lpFileName|"<<(lpFileName==NULL?"NULL":lpFileName)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealOpenFile(lpFileName,lpReOpenBuff,uStyle);
}
HANDLE WINAPI HookOpenMutexA(  DWORD dwDesiredAccess,  BOOL bInheritHandle,  LPCSTR lpName )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<OpenMutexA>,func_params=<lpName|"<<(lpName==NULL?"NULL":lpName)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealOpenMutexA(dwDesiredAccess,bInheritHandle,lpName);
}
LPVOID WINAPI HookMapViewOfFile(  HANDLE hFileMappingObject,  DWORD dwDesiredAccess,  DWORD dwFileOffsetHigh,  DWORD dwFileOffsetLow,  SIZE_T dwNumberOfBytesToMap )
{
	//WaitForSingleObject(hMutex,INFINITE);

	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<MapViewOfFile>,func_params=<dwNumberOfBytesToMap|"<<dwNumberOfBytesToMap<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealMapViewOfFile(hFileMappingObject,dwDesiredAccess,dwFileOffsetHigh,dwFileOffsetLow,dwNumberOfBytesToMap);
}
UINT WINAPI HookMapVirtualKeyA( UINT uCode,  UINT uMapType)
{
	//WaitForSingleObject(hMutex,INFINITE);

	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<MapVirtualKeyA>,func_params=<uCode|"<<uCode<<",uMapType|"<<uMapType<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealMapVirtualKeyA(uCode,uMapType);

}
SC_HANDLE WINAPI HookOpenSCManagerA(  LPCSTR lpMachineName,  LPCSTR lpDatabaseName,  DWORD dwDesiredAccess )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<OpenSCManagerA>,func_params=<lpMachineName|"<<(lpMachineName==NULL?"NULL":lpMachineName)<<",lpDatabaseName|"<<(lpDatabaseName==NULL?"NULL":lpDatabaseName)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealOpenSCManagerA(lpMachineName,lpDatabaseName,dwDesiredAccess);
}
BOOL WINAPI HookSetFileTime(  HANDLE hFile,  CONST FILETIME * lpCreationTime,  CONST FILETIME * lpLastAccessTime,  CONST FILETIME * lpLastWriteTime )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<SetFileTime>,func_params=<lpCreationTime|"<<lpCreationTime<<",lpLastAccessTime|"<<lpLastAccessTime<<",lpLastWriteTime|"<<lpLastWriteTime<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealSetFileTime(hFile,lpCreationTime,lpLastAccessTime,lpLastWriteTime);
}

/*
进程相关API
*/

BOOL WINAPI HookAdjustTokenPrivileges(  HANDLE TokenHandle,  BOOL DisableAllPrivileges,  PTOKEN_PRIVILEGES NewState,  DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState,  PDWORD ReturnLength )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<AdjustTokenPrivileges>,func_params=<DisableAllPrivileges|"<<DisableAllPrivileges<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealAdjustTokenPrivileges(TokenHandle,DisableAllPrivileges,NewState,BufferLength,PreviousState,ReturnLength);
}
BOOL WINAPI HookAttachThreadInput( DWORD idAttach,  DWORD idAttachTo,  BOOL fAttach)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<AttachThreadInput>,func_params=<idAttach|"<<idAttach<<",idAttachTo|"<<idAttachTo<<",fAttach|"<<fAttach<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealAttachThreadInput(idAttach,idAttachTo,fAttach);
}
LRESULT WINAPI HookCallNextHookEx( HHOOK hhk,  int nCode,  WPARAM wParam,  LPARAM lParam)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CallNextHookEx>,func_params=<nCode|"<<nCode<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealCallNextHookEx(hhk,nCode,wParam,lParam);
}
BOOL WINAPI HookCheckRemoteDebuggerPresent(  HANDLE hProcess,  PBOOL pbDebuggerPresent )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CheckRemoteDebuggerPresent>,func_params=<pbDebuggerPresent|"<<pbDebuggerPresent<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealCheckRemoteDebuggerPresent(hProcess,pbDebuggerPresent);
}
BOOL WINAPI HookControlService(  SC_HANDLE hService,  DWORD dwControl,  LPSERVICE_STATUS lpServiceStatus )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<ControlService>,func_params=<dwControl|"<<dwControl<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealControlService(hService,dwControl,lpServiceStatus);
}
BOOL WINAPI HookCreateProcessA(  LPCSTR lpApplicationName, LPSTR lpCommandLine,  LPSECURITY_ATTRIBUTES lpProcessAttributes,  LPSECURITY_ATTRIBUTES lpThreadAttributes,  BOOL bInheritHandles,  DWORD dwCreationFlags,  LPVOID lpEnvironment,  LPCSTR lpCurrentDirectory,  LPSTARTUPINFOA lpStartupInfo,  LPPROCESS_INFORMATION lpProcessInformation )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CreateProcessA>,func_params=<lpApplicationName|"<<lpApplicationName<<",lpCommandLine|"<<lpCommandLine<<",lpCurrentDirectory|"<<lpCurrentDirectory<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealCreateProcessA(lpApplicationName,lpCommandLine,lpProcessAttributes,lpThreadAttributes,bInheritHandles,dwCreationFlags,lpEnvironment,lpCurrentDirectory,lpStartupInfo,lpProcessInformation);
}
HANDLE WINAPI HookCreateRemoteThread(  HANDLE hProcess,  LPSECURITY_ATTRIBUTES lpThreadAttributes,  SIZE_T dwStackSize,  LPTHREAD_START_ROUTINE lpStartAddress,  LPVOID lpParameter,  DWORD dwCreationFlags,  LPDWORD lpThreadId )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CreateRemoteThread>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealCreateRemoteThread(hProcess,lpThreadAttributes,dwStackSize,lpStartAddress,lpParameter,dwCreationFlags,lpThreadId);
}
SC_HANDLE WINAPI HookCreateServiceA(  SC_HANDLE hSCManager,  LPCSTR lpServiceName,  LPCSTR lpDisplayName,  DWORD dwDesiredAccess,  DWORD dwServiceType,  DWORD dwStartType,  DWORD dwErrorControl,  LPCSTR lpBinaryPathName,  LPCSTR lpLoadOrderGroup,  LPDWORD lpdwTagId,  LPCSTR lpDependencies,  LPCSTR lpServiceStartName,  LPCSTR lpPassword )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CreateServiceA>,func_params=<lpServiceName|"<<lpServiceName<<",lpDisplayName|"<<lpDisplayName<<",lpBinaryPathName|"<<lpBinaryPathName<<",lpLoadOrderGroup|"<<lpLoadOrderGroup<<",lpServiceStartName|"<<lpServiceStartName<<",lpPassword|"<<lpPassword<<")>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealCreateServiceA(hSCManager,lpServiceName,lpDisplayName,dwDesiredAccess,dwServiceType,dwStartType,dwErrorControl,lpBinaryPathName,lpLoadOrderGroup,lpdwTagId,lpDependencies,lpServiceStartName,lpPassword);
}
HANDLE WINAPI HookCreateToolhelp32Snapshot( DWORD dwFlags, DWORD th32ProcessID )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CreateToolhelp32Snapshot>,func_params=<dwFlags|"<<dwFlags<<",th32ProcessID|"<<th32ProcessID<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealCreateToolhelp32Snapshot(dwFlags,th32ProcessID);
}
BOOL WINAPI HookEnumProcesses( DWORD * lpidProcess,  DWORD cb,  LPDWORD lpcbNeeded )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">proc_func_name=<EnumProcesses>,func_params=<cb|"<<cb<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealEnumProcesses(lpidProcess,cb,lpcbNeeded);
}
BOOL WINAPI HookEnumProcessModules(  HANDLE hProcess, HMODULE *lphModule,  DWORD cb,  LPDWORD lpcbNeeded )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<EnumProcessModules>,func_params=<cb|"<<cb<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealEnumProcessModules(hProcess,lphModule,cb,lpcbNeeded);
}
DWORD WINAPI HookGetModuleFileNameExA(  HANDLE hProcess,  HMODULE hModule, LPSTR lpFilename,  DWORD nSize )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetModuleFileNameExA>,func_params=<lpFilename|"<<(lpFilename==NULL?"NULL":lpFilename)<<">";
	//logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath();/*<<">,proc_func_name=<GetModuleFileNameExA>";
	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	
	return RealGetModuleFileNameExA(hProcess,hModule,lpFilename,nSize);
}
HMODULE WINAPI HookGetModuleHandleA(  LPCSTR lpModuleName )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetModuleHandleA>,func_params=<lpModuleName|"<<(lpModuleName==NULL?"NULL":lpModuleName)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealGetModuleHandleA(lpModuleName);
}
FARPROC WINAPI HookGetProcAddress(  HMODULE hModule,  LPCSTR lpProcName )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	//f<<LogTime()<<" pathname=<"<<GetProcessPath()<<">, pid=<"<<_getpid()<<">, function=<GetProcAddress(lpProcName="<<lpProcName<<")>"<<endl;
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetProcAddress>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealGetProcAddress(hModule,lpProcName);
}
VOID WINAPI HookGetStartupInfoA(  LPSTARTUPINFOA lpStartupInfo )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetStartupInfoA>,func_params=<lpStartupInfo|"<<lpStartupInfo<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealGetStartupInfoA(lpStartupInfo);
}
LANGID WINAPI HookGetSystemDefaultLangID()
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetSystemDefaultLangID>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealGetSystemDefaultLangID();
}
BOOL WINAPI HookGetThreadContext(  HANDLE hThread,  LPCONTEXT lpContext )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetThreadContext>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealGetThreadContext(hThread,lpContext);
}
DWORD WINAPI HookGetTickCount(VOID)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetTickCount>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealGetTickCount();
}
BOOL WINAPI HookGetVersionExA(  LPOSVERSIONINFOA lpVersionInformation )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetVersionExA>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealGetVersionExA(lpVersionInformation);
}
BOOL WINAPI HookIsDebuggerPresent()
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<IsDebuggerPresent>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealIsDebuggerPresent();
}
HMODULE WINAPI HookLoadLibraryA(  LPCSTR lpLibFileName )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<LoadLibraryA>,func_params=<lpLibFileName|"<<lpLibFileName<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealLoadLibraryA(lpLibFileName);
}
HGLOBAL WINAPI HookLoadResource(  HMODULE hModule,  HRSRC hResInfo )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<LoadResource>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealLoadResource(hModule,hResInfo);
}
BOOL WINAPI HookModule32FirstW( HANDLE hSnapshot, LPMODULEENTRY32W lpme )
{
	//WaitForSingleObject(hMutex,INFINITE);
	//::MessageBoxW(NULL,_T("Module32FirstW Hooked"),_T("APIHook"),0);//张宇南测试所加
	cout<<"Module32FirstW hooked!"<<endl;
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">, pid=<"<<_getpid()<<">,proc_func_name=<Module32FirstW>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MyModule32FirstW)RealModule32FirstW)(hSnapshot,lpme);//((MyModule32FirstW)RealModule32FirstW)
}
BOOL WINAPI HookModule32NextW( HANDLE hSnapshot, LPMODULEENTRY32W lpme )
{
	//WaitForSingleObject(hMutex,INFINITE);
	//::MessageBoxW(NULL,_T("Module32NextW Hooked"),_T("APIHook"),0);//张宇南测试所加
	cout<<"Module32NextW hooked!"<<endl;
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<Module32NextW>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MyModule32NextW)RealModule32NextW)(hSnapshot,lpme);
}
HANDLE WINAPI HookOpenProcess(  DWORD dwDesiredAccess,  BOOL bInheritHandle,  DWORD dwProcessId )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<OpenProcess>,func_params=<dwDesiredAccess|"<<dwDesiredAccess<<",bInheritHandle|"<<bInheritHandle<<",dwProcessId|"<<dwProcessId<<">";//这个函数内如果调用GetProcessPath会崩溃

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealOpenProcess(dwDesiredAccess,bInheritHandle,dwProcessId);
}
VOID WINAPI HookOutputDebugStringA(  LPCSTR lpOutputString )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	//logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<OutputDebugStringA>,func_params=<lpOutputString|"<<lpOutputString<<">";
	//lpOutputString可能出现\n会影响日志格式所以不输出这个参数
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<OutputDebugStringA>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealOutputDebugStringA(lpOutputString);
}
BOOL WINAPI HookPeekNamedPipe(  HANDLE hNamedPipe, LPVOID lpBuffer,  DWORD nBufferSize,  LPDWORD lpBytesRead,  LPDWORD lpTotalBytesAvail,  LPDWORD lpBytesLeftThisMessage )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<PeekNamedPipe>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealPeekNamedPipe(hNamedPipe,lpBuffer,nBufferSize,lpBytesRead,lpTotalBytesAvail,lpBytesLeftThisMessage);
}
BOOL WINAPI HookProcess32First( HANDLE hSnapshot, LPPROCESSENTRY32 lppe )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<Process32First>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealProcess32First(hSnapshot,lppe);
}
BOOL WINAPI HookProcess32Next( HANDLE hSnapshot, LPPROCESSENTRY32 lppe )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<Process32Next>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealProcess32Next(hSnapshot,lppe);
}
BOOL WINAPI HookQueryPerformanceCounter(  LARGE_INTEGER * lpPerformanceCount )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<QueryPerformanceCounter>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealQueryPerformanceCounter(lpPerformanceCount);
}
DWORD WINAPI HookQueueUserAPC(  PAPCFUNC pfnAPC,  HANDLE hThread,  ULONG_PTR dwData )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<QueueUserAPC>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealQueueUserAPC(pfnAPC,hThread,dwData);
}
BOOL WINAPI HookReadProcessMemory( HANDLE hProcess,  LPCVOID lpBaseAddress, LPVOID lpBuffer,  SIZE_T nSize,  SIZE_T * lpNumberOfBytesRead )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<ReadProcessMemory>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealReadProcessMemory(hProcess,lpBaseAddress,lpBuffer,nSize,lpNumberOfBytesRead);
}
DWORD WINAPI HookResumeThread(  HANDLE hThread )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<ResumeThread>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealResumeThread(hThread);
}
BOOL WINAPI HookSetThreadContext(  HANDLE hThread,  CONST CONTEXT * lpContext )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<SetThreadContext>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealSetThreadContext(hThread,lpContext);
}
HHOOK WINAPI HookSetWindowsHookExA( int idHook,  HOOKPROC lpfn,  HINSTANCE hmod,  DWORD dwThreadId)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<SetWindowsHookExA>,func_params=<idHook|"<<idHook<<",dwThreadId|"<<dwThreadId<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealSetWindowsHookExA(idHook,lpfn,hmod,dwThreadId);
}
HINSTANCE WINAPI HookShellExecuteA( HWND hwnd,  LPCSTR lpOperation,  LPCSTR lpFile,  LPCSTR lpParameters,  LPCSTR lpDirectory,  INT nShowCmd)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<ShellExecuteA>,func_params=<lpOperation|"<<lpOperation<<",lpFile|"<<lpFile<<",lpParameters|"<<lpParameters<<",lpDirectory|"<<lpDirectory<<",nShowCmd|"<<nShowCmd<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealShellExecuteA(hwnd,lpOperation,lpFile,lpParameters,lpDirectory,nShowCmd);
}
BOOL WINAPI HookStartServiceCtrlDispatcherA(  CONST SERVICE_TABLE_ENTRYA *lpServiceStartTable )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<StartServiceCtrlDispatcherA>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealStartServiceCtrlDispatcherA(lpServiceStartTable);
}
DWORD WINAPI HookSuspendThread(  HANDLE hThread )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<SuspendThread>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealSuspendThread(hThread);
}
int Hooksystem(const char * _Command)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<system>,func_params=<_Command|"<<_Command<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return Realsystem(_Command);
}
BOOL WINAPI HookThread32First( HANDLE hSnapshot, LPTHREADENTRY32 lpte )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<Thread32First>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealThread32First(hSnapshot,lpte);
}
BOOL WINAPI HookThread32Next( HANDLE hSnapshot, LPTHREADENTRY32 lpte )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<Thread32Next>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealThread32Next(hSnapshot,lpte);
}
BOOL WINAPI HookToolhelp32ReadProcessMemory( DWORD th32ProcessID, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T cbRead, SIZE_T *lpNumberOfBytesRead )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<Toolhelp32ReadProcessMemory>,func_params=<th32ProcessID|"<<th32ProcessID<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealToolhelp32ReadProcessMemory(th32ProcessID,lpBaseAddress,lpBuffer,cbRead,lpNumberOfBytesRead);
}
LPVOID WINAPI HookVirtualAllocEx( HANDLE hProcess,  LPVOID lpAddress,  SIZE_T dwSize,  DWORD flAllocationType,  DWORD flProtect )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<VirtualAllocEx>,func_params=<flAllocationType|"<<flAllocationType<<",flProtect|"<<flProtect<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealVirtualAllocEx(hProcess,lpAddress,dwSize,flAllocationType,flProtect);
}
BOOL WINAPI HookVirtualProtectEx(  HANDLE hProcess ,  LPVOID lpAddress,  SIZE_T dwSize,  DWORD flNewProtect,  PDWORD lpflOldProtect )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<VirtualProtectEx>,func_params=<flNewProtect|"<<flNewProtect<<",lpflOldProtect|"<<lpflOldProtect<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealVirtualProtectEx(hProcess,lpAddress,dwSize,flNewProtect,lpflOldProtect);
}
UINT WINAPI HookWinExec(  LPCSTR lpCmdLine,  UINT uCmdShow )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<WinExec>,func_params=<lpCmdLine|"<<lpCmdLine<<",uCmdShow|"<<uCmdShow<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealWinExec(lpCmdLine,uCmdShow);
}
BOOL WINAPI HookWriteProcessMemory( HANDLE hProcess,  LPVOID lpBaseAddress, LPCVOID lpBuffer,  SIZE_T nSize,  SIZE_T * lpNumberOfBytesWritten )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<WriteProcessMemory>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealWriteProcessMemory(hProcess,lpBaseAddress,lpBuffer,nSize,lpNumberOfBytesWritten);
}
BOOL WINAPI HookRegisterHotKey( HWND hWnd,  int id,  UINT fsModifiers,  UINT vk)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<RegisterHotKey>,func_params=<id|"<<id<<",fsModifiers|"<<fsModifiers<<",vk|"<<vk<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealRegisterHotKey(hWnd,id,fsModifiers,vk);
}
BOOL WINAPI HookCreateProcessW(LPCWSTR lpApplicationName,LPWSTR lpCommandLine,LPSECURITY_ATTRIBUTES lpProcessAttributes,LPSECURITY_ATTRIBUTES lpThreadAttributes,BOOL bInheritHandles,DWORD dwCreationFlags,LPVOID lpEnvironment,LPCWSTR lpCurrentDirectory,LPSTARTUPINFOW lpStartupInfo,LPPROCESS_INFORMATION lpProcessInformation)
{
	DWORD dwLastError = GetLastError();
	BOOL  bResult = FALSE;
	CHAR  szDetouredDll[MAX_PATH];
	CHAR  szDllName[MAX_PATH];
	HMODULE hMod1 = NULL, hMod2 = NULL;

	// get the full path to the detours DLL
	hMod1 = GetModuleHandleA("detoured.dll");
	GetModuleFileNameA(hMod1, szDetouredDll, MAX_PATH);

	// get the full path to the hooking DLL
	GetModuleHandleEx(
		GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, 
		(LPCTSTR)&HookCreateProcessW,
		&hMod2);

	GetModuleFileNameA(hMod2, szDllName, MAX_PATH);

	OutputDebugStringA(szDllName);
	OutputDebugStringA(szDetouredDll);
	OutputDebugStringA("\n");

	//wprintf(L"[DetoursHooks] Intercepting the creation of %s\n", lpCommandLine);

	// route creation of new process through 
	// the detours API 
	bResult = DetourCreateProcessWithDllW(
		lpApplicationName,
		lpCommandLine, 
		lpProcessAttributes,
		lpThreadAttributes,
		bInheritHandles,
		dwCreationFlags,
		lpEnvironment, 
		lpCurrentDirectory,
		lpStartupInfo, 
		lpProcessInformation, 
		//szDetouredDll, 
		szDllName, 
		(PDETOUR_CREATE_PROCESS_ROUTINEW)RealCreateProcessW);

	SetLastError(dwLastError);
	return bResult;
}
//这个函数到底调试了没有？ 张宇南 2015/10/17.

/*
注册表相关
*/
LONG WINAPI HookRegOpenKeyA(  HKEY hKey,  LPCSTR lpSubKey,  PHKEY phkResult )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<RegOpenKeyA>,func_params=<lpSubKey|"<<lpSubKey<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealRegOpenKeyA(hKey,lpSubKey,phkResult);
}
LONG WINAPI HookRegOpenKeyEx(HKEY hKey,LPCWSTR lpSubKey,DWORD ulOptions,REGSAM samDesired,PHKEY phkResult)
{
	//WaitForSingleObject(hMutex,INFINITE);
/*	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<RegOpenKeyEx>,func_params=<lpSubKey|"<<lpSubKey<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);*/
	return RealRegOpenKeyEx(hKey,lpSubKey,ulOptions,samDesired,phkResult);
}

/*
网络相关
*/
int WSAAPI Hookconnect(  SOCKET s, const struct sockaddr FAR * name,  int namelen )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	sockaddr_in* sock;
	int socklen=sizeof(sock);
	sock=(struct sockaddr_in *)name;
	char *sock_ip=inet_ntoa((*sock).sin_addr);
	/*
	if(0==getsockname(s,(struct sockaddr*)&sock,&socklen)){
		char *sock_ip=inet_ntoa(sock.sin_addr);
	}
	*/
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<connect>,func_params=<ip|"<<sock_ip<<",name|"<<name<<",namelen|"<<namelen<<">";

	string st,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((Myconnect)Realconnect)(s,name,namelen);
}
int WSAAPI Hookbind(  SOCKET s, const struct sockaddr FAR * name,  int namelen )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	sockaddr_in* sock;
	int socklen=sizeof(sock);
	sock=(struct sockaddr_in *)name;
	char *sock_ip=inet_ntoa((*sock).sin_addr);
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<bind>,func_params=<ip|"<<sock_ip<<",s|"<<s<<",name|"<<name<<",namelen|"<<namelen<<">";

	string st,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return((Mybind)Realbind)(s,name,namelen);
}
SOCKET WSAAPI Hookaccept(  SOCKET s, struct sockaddr FAR * addr, int FAR * addrlen )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	sockaddr_in sock;
	int socklen=sizeof(sock);
	//char sock_ip[]="NULL";
	//char sock_ip[1000]="NULL";
	getsockname(s,(struct sockaddr*)&sock,&socklen);
	char *sock_ip=inet_ntoa(sock.sin_addr);
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<accept>,func_params=<ip|"<<sock_ip<<",s|"<<s<<",addr|"<<addr<<">";

	string st,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((Myaccept)Realaccept)(s,addr,addrlen);
}
int WINAPI Hooksend(SOCKET s,const char *buf,int len,int flags)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	sockaddr_in sock;
	int socklen=sizeof(sock);
	//char sock_ip[]="NULL";
	//char sock_ip[1000]="NULL";
	getsockname(s,(struct sockaddr*)&sock,&socklen);
	char *sock_ip=inet_ntoa(sock.sin_addr);
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<send>,func_params=<ip|"<<sock_ip<<",s|"<<s<<",len|"<<len<<",flags|"<<flags<<">";

	string st,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MySend)Realsend)(s,buf,len,flags);
}
BOOL WINAPI HookConnectNamedPipe(  HANDLE hNamedPipe,LPOVERLAPPED lpOverlapped )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<ConnectNamedPipe>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealConnectNamedPipe(hNamedPipe,lpOverlapped);
}
ULONG WINAPI HookGetAdaptersInfo( PIP_ADAPTER_INFO AdapterInfo,  PULONG SizePointer )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetAdaptersInfo>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MyGetAdaptersInfo)RealGetAdaptersInfo)(AdapterInfo,SizePointer);
}
struct hostent* FAR WINAPI Hookgethostbyname( const char FAR * name )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<gethostbyname>,func_params=<name|"<<name<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((Mygethostbyname)Realgethostbyname)(name);
}
int WSAAPI Hookgethostname( char FAR * name,  int namelen )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<gethostname>,func_params=<name|"<<static_cast<const void *>(name)<<",namelen|"<<namelen<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((Mygethostname)Realgethostname)(name,namelen);
}
unsigned long WSAAPI Hookinet_addr( const char FAR * cp )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<inet_addr>,func_params=<cp|"<<cp<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((Myinet_addr)Realinet_addr)(cp);
}

EXTERN_C HINTERNET STDAPICALLTYPE HookInternetOpenA( LPCSTR lpszAgent,  DWORD dwAccessType,  LPCSTR lpszProxy,  LPCSTR lpszProxyBypass,  DWORD dwFlags )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<InternetOpenA>,func_params=<lpszAgent|"<<(lpszAgent==NULL?"NULL":lpszAgent)<<",dwAccessType|"<<dwAccessType<<",lpszProxy|"<<(lpszProxy==NULL?"NULL":lpszProxy)<<",lpszProxyBypass|"<<(lpszProxyBypass==NULL?"NULL":lpszProxyBypass)<<",dwFlags|"<<dwFlags<<">";

	string s,sm;
	sm="";
	
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);

	return ((MyInternetOpenA)RealInternetOpenA)(lpszAgent,dwAccessType,lpszProxy,lpszProxyBypass,dwFlags);
}

//by zhangyunan this func
EXTERN_C HINTERNET STDAPICALLTYPE HookInternetOpenW( LPCWSTR lpszAgent,  DWORD dwAccessType,  LPCWSTR lpszProxy,  LPCWSTR lpszProxyBypass,  DWORD dwFlags )
{
	stringstream logstream;
	logstream.clear();
	
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<InternetOpenW>,func_params=<lpszAgent|"<<(lpszAgent==NULL?L"NULL":lpszAgent)<<",dwAccessType|"<<dwAccessType<<",lpszProxy|"<<(lpszProxy==NULL?L"NULL":lpszProxy)<<",lpszProxyBypass|"<<(lpszProxyBypass==NULL?L"NULL":lpszProxyBypass)<<",dwFlags|"<<dwFlags<<">";

	string s,sm;
	sm="";
	
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);

	return ((MyInternetOpenW)RealInternetOpenW)(lpszAgent,dwAccessType,lpszProxy,lpszProxyBypass,dwFlags);
}

EXTERN_C HINTERNET STDAPICALLTYPE HookInternetOpenUrlA(  HINTERNET hInternet,  LPCSTR lpszUrl, LPCSTR lpszHeaders,  DWORD dwHeadersLength,  DWORD dwFlags,  DWORD_PTR dwContext )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<InternetOpenUrlA>,func_params=<lpszUrl|"<<(lpszUrl==NULL?"NULL":lpszUrl)<<",lpszHeaders|"<<(lpszHeaders==NULL?"NULL":lpszHeaders)<<",dwHeadersLength|"<<dwHeadersLength<<",dwFlags|"<<dwFlags<<",dwContext|"<<dwContext<<">";

	string s,sm;
	sm="";
	
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MyInternetOpenUrlA)RealInternetOpenUrlA)(hInternet,lpszUrl,lpszHeaders,dwHeadersLength,dwFlags,dwContext);
}
//by zhangyunan this func
EXTERN_C HINTERNET STDAPICALLTYPE HookInternetOpenUrlW(  HINTERNET hInternet,  LPCWSTR lpszUrl, LPCWSTR lpszHeaders,  DWORD dwHeadersLength,  DWORD dwFlags,  DWORD_PTR dwContext )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<InternetOpenUrlW>,func_params=<lpszUrl|"<<(lpszUrl==NULL?L"NULL":lpszUrl)<<",lpszHeaders|"<<(lpszHeaders==NULL?L"NULL":lpszHeaders)<<",dwHeadersLength|"<<dwHeadersLength<<",dwFlags|"<<dwFlags<<",dwContext|"<<dwContext<<">";

	string s,sm;
	sm="";
	
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MyInternetOpenUrlW)RealInternetOpenUrlW)(hInternet,lpszUrl,lpszHeaders,dwHeadersLength,dwFlags,dwContext);
}
BOOL WINAPI HookInternetReadFile(  HINTERNET hFile,  LPVOID lpBuffer,  DWORD dwNumberOfBytesToRead,  LPDWORD lpdwNumberOfBytesRead )
{
	//WaitForSingleObject(hMutex,INFINITE);
	//GetFileNameFromHandle(hFile);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<InternetReadFile>,func_params=<dwNumberOfBytesToRead|"<<dwNumberOfBytesToRead<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MyInternetReadFile)RealInternetReadFile)(hFile,lpBuffer,dwNumberOfBytesToRead,lpdwNumberOfBytesRead);
}
BOOL WINAPI HookInternetWriteFile(  HINTERNET hFile,  LPCVOID lpBuffer,  DWORD dwNumberOfBytesToWrite,  LPDWORD lpdwNumberOfBytesWritten )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<InternetWriteFile>,func_params=<dwNumberOfBytesToWrite|"<<dwNumberOfBytesToWrite<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MyInternetWriteFile)RealInternetWriteFile)(hFile,lpBuffer,dwNumberOfBytesToWrite,lpdwNumberOfBytesWritten);
}
DWORD WINAPI HookNetShareEnum(  LMSTR servername,  DWORD level,  LPBYTE *bufptr,  DWORD prefmaxlen,  LPDWORD entriesread,  LPDWORD totalentries, LPDWORD resume_handle )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<NetShareEnum>,func_params=<servername|"<<servername<<",level|"<<level<<",prefmaxlen|"<<prefmaxlen<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MyNetShareEnum)RealNetShareEnum)(servername,level,bufptr,prefmaxlen,entriesread,totalentries,resume_handle);
}
int WSAAPI Hookrecv(  SOCKET s, char FAR * buf,  int len,  int flags )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	sockaddr_in sock;
	int socklen=sizeof(sock);
	//char sock_ip[]="NULL";
	//char sock_ip[1000]="NULL";
	getsockname(s,(struct sockaddr*)&sock,&socklen);
	char *sock_ip=inet_ntoa(sock.sin_addr);
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<recv>,func_params=<ip|"<<sock_ip<<",s|"<<s<<",len|"<<len<<",flags|"<<flags<<">";

	string st,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((Myrecv)Realrecv)(s,buf,len,flags);
}
HRESULT WINAPI HookURLDownloadToFileA(LPUNKNOWN pCaller,LPCSTR szURL,LPCSTR szFileName,DWORD dwReserved,LPBINDSTATUSCALLBACK lpfnCB)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<URLDownloadToFileA>,func_params=<szURL|"<<szURL<<",szFileName|"<<szFileName<<",dwReserved|"<<dwReserved<<">";

	string s,sm;
	sm="";
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MyURLDownloadToFileA)RealURLDownloadToFileA)(pCaller,szURL,szFileName,dwReserved,lpfnCB);
}

//by zhangyunan this func
HRESULT WINAPI HookURLDownloadToFileW(LPUNKNOWN pCaller,LPCWSTR szURL,LPCWSTR szFileName,DWORD dwReserved,LPBINDSTATUSCALLBACK lpfnCB)
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<URLDownloadToFileW>,func_params=<szURL|"<<szURL<<",szFileName|"<<szFileName<<",dwReserved|"<<dwReserved<<">";

	string s,sm;
	sm="";
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MyURLDownloadToFileW)RealURLDownloadToFileW)(pCaller,szURL,szFileName,dwReserved,lpfnCB);
}
int WSAAPI HookWSAStartup(  WORD wVersionRequested,  LPWSADATA lpWSAData )
{
	//WaitForSingleObject(hMutex,INFINITE);
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<WSAStartup>,func_params=<wVersionRequested|"<<wVersionRequested<<",lpWSAData|"<<lpWSAData<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MyWSAStartup)RealWSAStartup)(wVersionRequested,lpWSAData);
}


//author zhangyunan
HANDLE WINAPI HookCreateFileW(LPCWSTR lpFileName,DWORD dwDesiredAccess,DWORD dwShareMode,LPSECURITY_ATTRIBUTES lpSecurityAttributes,DWORD dwCreationDisposition,DWORD dwFlagsAndAttributes,HANDLE hTemplateFile)
{
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CreateFileW>,func_params=<lpFileName|"<<lpFileName<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	//ofstream f(log_path,ios::app);
	//f<<sm;
	//f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealCreateFileW(lpFileName,dwDesiredAccess,dwShareMode,lpSecurityAttributes,dwCreationDisposition,dwFlagsAndAttributes,hTemplateFile);
}
BOOL WINAPI HookMoveFileW(LPCWSTR lpExistingFileName,LPCWSTR lpNewFileName){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<MoveFileW>,func_params=<lpExistingFileName|"<<lpExistingFileName<<",lpNewFileName|"<<lpNewFileName<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealMoveFileW(lpExistingFileName,lpNewFileName);
}

BOOL WINAPI HookCopyFileW(LPCWSTR lpExistingFileName,LPCWSTR lpNewFileName, BOOL bFailIfExists){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CopyFileW>,func_params=<lpExistingFileName|"<<lpExistingFileName<<",lpNewFileName|"<<lpNewFileName<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealCopyFileW(lpExistingFileName,lpNewFileName,bFailIfExists);
}

BOOL WINAPI HookDeleteFileW(LPCWSTR lpFileName){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<DeleteFileW>,func_params=<lpFileName|"<<lpFileName<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealDeleteFileW(lpFileName);
}

//static BOOL (WINAPI *RealDeleteFileW)( LPCWSTR lpFileName) = DeleteFileW;
HANDLE WINAPI HookFindFirstFileW(LPCWSTR lpFileName,LPWIN32_FIND_DATAW lpFindFileData){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<FindFirstFileW>,func_params=<lpFileName|"<<lpFileName<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealFindFirstFileW(lpFileName,lpFindFileData);
}
//static HANDLE (WINAPI *RealFindFirstFileW)( LPCWSTR,  LPWIN32_FIND_DATAW)=FindFirstFileW;
BOOL WINAPI HookFindNextFileW(HANDLE hFindFile,LPWIN32_FIND_DATA lpFindFileData){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<FindNextFileW>"<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealFindNextFileW(hFindFile,lpFindFileData);
}

//static BOOL (WINAPI *RealFindNextFileW)( HANDLE hFindFile,  LPWIN32_FIND_DATAW lpFindFileData)=FindNextFileW;
HCERTSTORE WINAPI HookCertOpenSystemStoreW(HCRYPTPROV_LEGACY hProv,LPCWSTR szSubsystemProtocol){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CertOpenSystemStoreW>,func_params=<szSubsystemProtocol|"<<szSubsystemProtocol<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealCertOpenSystemStoreW(hProv,szSubsystemProtocol);
}

//static HCERTSTORE (WINAPI *RealCertOpenSystemStore)( HCRYPTPROV_LEGACY hProv,  LPCWSTR szSubsystemProtocol)=CertOpenSystemStoreW;
HANDLE WINAPI HookCreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CreateMutexW>,func_params=<lpName|"<<lpName<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealCreateMutexW(lpMutexAttributes,bInitialOwner,lpName);
}

//static HANDLE (WINAPI *RealCreateMutexW)( LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)=CreateMutexW;
HRSRC WINAPI HookFindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<FindResourceW>,func_params=<lpName|"<<lpName<<",lpType|"<<lpType<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealFindResourceW(hModule,lpName,lpType);
}

//static HRSRC (WINAPI *RealFindResourceW)( HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)=FindResourceW;
HWND WINAPI HookFindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<FindWindowW>,func_params=<lpClassName|"<<(lpClassName==NULL?L"NULL":lpClassName)<<",lpWindowName|"<<(lpWindowName==NULL?L"NULL":lpWindowName)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MyFindWindowW)RealFindWindowW)(lpClassName,lpWindowName);
}

//static HWND (WINAPI *RealFindWindowW)( LPCWSTR lpClassName, LPCWSTR lpWindowName)=FindWindowW;
UINT WINAPI HookGetWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetWindowsDirectoryW>,func_params=<lpBuffer|"<<lpBuffer<<",uSize|"<<uSize<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealGetWindowsDirectoryW(lpBuffer,uSize);
}

//static UINT (WINAPI *RealGetWindowsDirectoryW)( LPWSTR lpBuffer, UINT uSize)=GetWindowsDirectoryW;
UINT WINAPI HookMapVirtualKeyW(UINT uCode, UINT uMapType){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<MapVirtualKeyW>,func_params=<uCode|"<<uCode<<",uMapType|"<<uMapType<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MyMapVirtualKeyW)RealMapVirtualKeyW)(uCode,uMapType);
}
//static UINT (WINAPI *RealMapVirtualKeyW)( UINT uCode, UINT uMapType)=MapVirtualKeyW;

HANDLE WINAPI HookOpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<OpenMutexW>,func_params=<lpName|"<<(lpName==NULL?L"NULL":lpName)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealOpenMutexW(dwDesiredAccess,bInheritHandle,lpName);
}
//static HANDLE (WINAPI *RealOpenMutexW)( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)=OpenMutexW;

HANDLE WINAPI HookOpenSCManagerW(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<OpenSCManagerW>,func_params=<lpMachineName|"<<(lpMachineName==NULL?L"NULL":lpMachineName)<<",lpDatabaseName|"<<(lpDatabaseName==NULL?L"NULL":lpDatabaseName)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealOpenSCManagerW(lpMachineName,lpDatabaseName,dwDesiredAccess);
}
//static SC_HANDLE (WINAPI *RealOpenSCManagerW)( LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess)=OpenSCManagerW;
//BOOL WINAPI HookCreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation){
//	::MessageBoxW(NULL,_T("CreateProcessW Hooked"),_T("APIHook"),0);//张宇南测试所加
//	stringstream logstream;
//	logstream.clear();
//	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CreateProcessW>,func_params=<lpApplicationName|"<<lpApplicationName<<",lpCommandLine|"<<lpCommandLine<<",lpProcessAttributes|"<<lpProcessAttributes<<",lpThreadAttributes|"<<lpThreadAttributes<<",bInheritHandles|"<<bInheritHandles<<",dwCreationFlags|"<<dwCreationFlags<<",lpEnvironment|"<<lpEnvironment<<",lpCurrentDirectory|"<<lpCurrentDirectory<<",lpStartupInfo|"<<lpStartupInfo<<",lpProcessInformation|"<<lpProcessInformation<<">";
//
//	string s,sm;
//	sm="";
//	sm=logstream.str();
//	sm=sm+"\n\0";
//	ofstream f(log_path,ios::app);
//	f<<sm;
//	f.close();
//	sm="";
//	logstream.clear();
//	//MoveLog();
//	//ReleaseMutex(hMutex);
//	return RealCreateProcessW(lpApplicationName,lpCommandLine,lpProcessAttributes,lpThreadAttributes,bInheritHandles,dwCreationFlags,lpEnvironment,lpCurrentDirectory,lpStartupInfo,lpProcessInformation);
//}
//static BOOL (WINAPI *RealCreateProcessW)( LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)=CreateProcessW;

SC_HANDLE WINAPI HookCreateServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPCWSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CreateServiceW>,func_params=<hSCManager|"<<hSCManager<<",lpServiceName|"<<lpServiceName<<",lpDisplayName|"<<lpDisplayName<<",dwDesiredAccess|"<<dwDesiredAccess<<",dwServiceType|"<<dwServiceType<<",dwStartType|"<<dwStartType<<",dwErrorControl|"<<dwErrorControl<<",lpBinaryPathName|"<<lpBinaryPathName<<",lpLoadOrderGroup|"<<lpLoadOrderGroup<<",lpdwTagId|"<<lpdwTagId<<",lpDependencies|"<<lpDependencies<<",lpServiceStartName|"<<lpServiceStartName<<",lpPassword|"<<lpPassword<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealCreateServiceW(hSCManager,lpServiceName,lpDisplayName,dwDesiredAccess,dwServiceType,dwStartType,dwErrorControl,lpBinaryPathName,lpLoadOrderGroup,lpdwTagId,lpDependencies,lpServiceStartName,lpPassword);
}
//static SC_HANDLE (WINAPI *RealCreateServiceW)( SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPCWSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword)=CreateServiceW;
DWORD WINAPI HookGetModuleFileNameExW(HANDLE hProcess, HMODULE hModule, LPWSTR lpFileName, DWORD nSize){
	cout<<"GetModuleFileNameExW hooked!"<<endl;
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetModuleFileNameExW>,func_params=<lpFileName|"<<(lpFileName==NULL?L"NULL":lpFileName)<<">";//(lpValue==NULL?"NULL":lpValue)

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealGetModuleFileNameExW(hProcess,hModule,lpFileName,nSize);
}
//return ((MyMapVirtualKeyW)RealMapVirtualKeyW)(uCode,uMapType);
//static DWORD (WINAPI *RealGetModuleFileNameExW)( HANDLE hProcess, HMODULE hModule, LPWSTR lpFileName, DWORD nSize)=GetModuleFileNameExW;

HMODULE WINAPI HookGetModuleHandleW(LPCWSTR lpModuleName){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetModuleHandleW>,func_params=<lpModuleName|"<<(lpModuleName==NULL?L"NULL":lpModuleName)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealGetModuleHandleW(lpModuleName);
}
//static HMODULE (WINAPI *RealGetModuleHandleW)( LPCWSTR lpModuleName)=GetModuleHandleW;

VOID WINAPI HookGetStartupInfoW(LPSTARTUPINFOW lpStartupInfo){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetStartupInfoW>,func_params=<lpStartupInfo|"<<lpStartupInfo<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealGetStartupInfoW(lpStartupInfo);
}
//static VOID (WINAPI *RealGetStartupInfoW)( LPSTARTUPINFOW lpStartupInfo)=GetStartupInfoW;
BOOL WINAPI HookGetVersionExW(LPOSVERSIONINFOW lpVersionInfo){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<GetVersionExW"<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealGetVersionExW(lpVersionInfo);
}
//static BOOL (WINAPI *RealGetVersionExW)( LPOSVERSIONINFOW lpVersionInfo)=GetVersionExW;

HMODULE WINAPI HookLoadLibraryW(LPCWSTR lpFileName){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<LoadLibraryW>,func_params=<lpFileName|"<<lpFileName<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealLoadLibraryW(lpFileName);
}
//static HMODULE (WINAPI *RealLoadLibraryW)( LPCWSTR lpFileName)=LoadLibraryW;

VOID WINAPI HookOutputDebugStringW(LPCWSTR lpOutputString){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<OutputDebugStringW>,func_params=<lpOutputString|"<<lpOutputString<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealOutputDebugStringW(lpOutputString);
}
//static VOID (WINAPI *RealOutputDebugStringW)( LPCWSTR lpOutputString)=OutputDebugStringW;

HHOOK WINAPI HookSetWindowsHookExW(int idHook, HOOKPROC lpfn, HINSTANCE hMod, DWORD dwThreadId){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<SetWindowsHookExW>,func_params=<idHook|"<<idHook<<",dwThreadId|"<<dwThreadId<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealSetWindowsHookExW(idHook,lpfn,hMod,dwThreadId);
}
//static HHOOK (WINAPI *RealSetWindowsHookExW)( int idHook, HOOKPROC lpfn, HINSTANCE hMod, DWORD dwThreadId)=SetWindowsHookExW;

HINSTANCE WINAPI HookShellExecuteW( HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<ShellExecuteW>,func_params=<lpOperation|"<<(lpOperation==NULL?L"NULL":lpOperation)<<",lpFile|"<<lpFile<<",lpParameters|"<<(lpParameters==NULL?L"NULL":lpParameters)<<",lpDirectory|"<<(lpDirectory==NULL?L"NULL":lpDirectory)<<",nShowCmd|"<<nShowCmd<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealShellExecuteW(hwnd,lpOperation,lpFile,lpParameters,lpDirectory,nShowCmd);
}
//static HINSTANCE (WINAPI *RealShellExecuteW)( HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd)=ShellExecuteW;

BOOL WINAPI HookStartServiceCtrlDispatcherW( CONST SERVICE_TABLE_ENTRYW *lpServiceTable){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<StartServiceCtrlDispatcherW>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealStartServiceCtrlDispatcherW(lpServiceTable);
}
//static BOOL (WINAPI *RealStartServiceCtrlDispatcherW)( CONST SERVICE_TABLE_ENTRYW *lpServiceTable)=StartServiceCtrlDispatcherW;

LONG WINAPI HookRegOpenKeyW( HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<RegOpenKeyW>,func_params=<hKey|"<<hKey<<",lpSubKey|"<<(lpSubKey==NULL?L"NULL":lpSubKey)<<",phkResult|"<<phkResult<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealRegOpenKeyW(hKey,lpSubKey,phkResult);
}
//static LONG (WINAPI *RealRegOpenKeyW)( HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)=RegOpenKeyW;

BOOL WINAPI HookModule32Next( HANDLE hSnapshot, LPMODULEENTRY32 lpme ){
	cout<<"Module32Next hooked!"<<endl;
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<Module32Next>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MyModule32Next)RealModule32Next)(hSnapshot,lpme);
}
//static BOOL (WINAPI *RealModule32Next)( HANDLE hSnapshot, LPMODULEENTRY32 lpme )=Module32Next;
BOOL WINAPI HookModule32First( HANDLE hSnapshot, LPMODULEENTRY32 lpme ){
	cout<<"Module32First hooked!"<<endl;
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<Module32First>";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return ((MyModule32First)RealModule32First)(hSnapshot,lpme);
}
//static BOOL (WINAPI *RealModule32First)( HANDLE hSnapshot, LPMODULEENTRY32 lpme )=Module32First;

LONG WINAPI HookRegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<CreateKeyExA>,func_params=<hKey|"<<hKey<<",lpSubKey|"<<(lpSubKey==NULL?"NULL":lpSubKey)<<",lpClass|"<<(lpClass==NULL?"NULL":lpClass)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealRegCreateKeyExA(hKey,lpSubKey,Reserved,lpClass,dwOptions,samDesired,lpSecurityAttributes,phkResult,lpdwDisposition);
}
//static LONG (WINAPI *RealRegCreateKeyExA)( HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)=RegCreateKeyExA;
LONG WINAPI HookRegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<RegCreateKeyExW>,func_params=<hKey|"<<hKey<<",lpSubKey|"<<(lpSubKey==NULL?L"NULL":lpSubKey)<<",lpClass|"<<(lpClass==NULL?L"NULL":lpClass)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealRegCreateKeyExW(hKey,lpSubKey,Reserved,lpClass,dwOptions,samDesired,lpSecurityAttributes,phkResult,lpdwDisposition);
}
//static LONG (WINAPI *RealRegCreateKeyExA)( HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)=RegCreateKeyExW;

LONG WINAPI HookRegCreateKeyA(  HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<RegCreateKeyA>,func_params=<hKey|"<<hKey<<",lpSubKey|"<<(lpSubKey==NULL?"NULL":lpSubKey)<<",phkResult|"<<phkResult<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealRegOpenKeyA(hKey,lpSubKey,phkResult);
}
//static LONG (WINAPI *RealRegCreateKeyA)( HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)=RegCreateKeyA;
LONG WINAPI HookRegCreateKeyW(  HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<RegCreateKeyW>,func_params=<hKey|"<<hKey<<",lpSubKey|"<<(lpSubKey==NULL?L"NULL":lpSubKey)<<",phkResult|"<<phkResult<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealRegOpenKeyW(hKey,lpSubKey,phkResult);
}
//static LONG (WINAPI *RealRegCreateKeyW)( HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)=RegCreateKeyW;

LONG WINAPI HookRegQueryValueExA(  HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<RegQueryValueExA>,func_params=<hKey|"<<hKey<<",lpValueName|"<<(lpValueName==NULL?"NULL":lpValueName)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealRegQueryValueExA(hKey,lpValueName,lpReserved,lpType,lpData,lpcbData);
}
//static LONG (WINAPI *RealRegQueryValueExA)( HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)=RegQueryValueExA;
LONG WINAPI HookRegQueryValueExW(  HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<RegQueryValueExW>,func_params=<hKey|"<<hKey<<",lpValueName|"<<(lpValueName==NULL?L"NULL":lpValueName)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealRegQueryValueExW(hKey,lpValueName,lpReserved,lpType,lpData,lpcbData);
}
//static LONG (WINAPI *RealRegQueryValueExW)( HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)=RegQueryValueExW;

LONG WINAPI HookRegQueryValueA( HKEY hKey, LPCSTR lpSubKey, LPSTR lpValue, PLONG lpcbValue){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<RegQueryValueA>,func_params=<hKey|"<<hKey<<",lpSubKey|"<<(lpSubKey==NULL?"NULL":lpSubKey)<<",lpValue|"<<(lpValue==NULL?"NULL":lpValue)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealRegQueryValueA( hKey, lpSubKey, lpValue, lpcbValue);
}
//static LONG (WINAPI *RealRegQueryValueA)( HKEY hKey, LPCSTR lpSubKey, LPSTR lpValue, PLONG lpcbValue)=RegQueryValueA;
LONG WINAPI HookRegQueryValueW( HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpValue, PLONG lpcbValue){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<RegQueryValueW>,func_params=<hKey|"<<hKey<<",lpSubKey|"<<(lpSubKey==NULL?L"NULL":lpSubKey)<<",lpValue|"<<(lpValue==NULL?L"NULL":lpValue)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealRegQueryValueW( hKey, lpSubKey, lpValue, lpcbValue);
}
//static LONG (WINAPI *RealRegQueryValueW)( HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpValue, PLONG lpcbValue)=RegQueryValueW;

LONG WINAPI HookRegSetValueExA(  HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<RegSetValueExA>,func_params=<hKey|"<<hKey<<",lpValueName|"<<(lpValueName==NULL?"NULL":lpValueName)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealRegSetValueExA(hKey,lpValueName,Reserved,dwType,lpData,cbData);
}
//static LONG (WINAPI *RealRegSetValueExA)( HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)=RegSetValueExA;
LONG WINAPI HookRegSetValueExW(  HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<RegSetValueExW>,func_params=<hKey|"<<hKey<<",lpValueName|"<<(lpValueName==NULL?L"NULL":lpValueName)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealRegSetValueExW(hKey,lpValueName,Reserved,dwType,lpData,cbData);
}
//static LONG (WINAPI *RealRegSetValueExW)( HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)=RegSetValueExW;

LONG WINAPI HookRegSetValueA( HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<RegSetValueA>,func_params=<hKey|"<<hKey<<",lpSubKey|"<<(lpSubKey==NULL?"NULL":lpSubKey)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealRegSetValueA(hKey,lpSubKey,dwType,lpData,cbData);
}
//static LONG (WINAPI *RealRegSetValueA)( HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData)=RegSetValueA;
LONG WINAPI HookRegSetValueW( HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<RegSetValueW>,func_params=<hKey|"<<hKey<<",lpSubKey|"<<(lpSubKey==NULL?L"NULL":lpSubKey)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealRegSetValueW(hKey,lpSubKey,dwType,lpData,cbData);
}
//static LONG (WINAPI *RealRegSetValueW)( HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData)=RegSetValueW;

LONG WINAPI HookRegDeleteKeyExA(  HKEY hKey, LPCSTR lpSubKey,REGSAM samDesired, DWORD Reserved){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<RegDeleteKeyExA>,func_params=<hKey|"<<hKey<<",lpSubKey|"<<(lpSubKey==NULL?"NULL":lpSubKey)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealRegDeleteKeyExA(hKey,lpSubKey,samDesired,Reserved);
}
//static LONG (WINAPI *RealRegDeleteKeyExA)( HKEY hKey, LPCSTR lpSubKey,REGSAM samDesired, DWORD Reserved)=RegDeleteKeyExA;
LONG WINAPI HookRegDeleteKeyExW(  HKEY hKey, LPCWSTR lpSubKey,REGSAM samDesired, DWORD Reserved){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<RegDeleteKeyExW>,func_params=<hKey|"<<hKey<<",lpSubKey|"<<(lpSubKey==NULL?L"NULL":lpSubKey)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealRegDeleteKeyExW(hKey,lpSubKey,samDesired,Reserved);
}
//static LONG (WINAPI *RealRegDeleteKeyExW)( HKEY hKey, LPCWSTR lpSubKey,REGSAM samDesired, DWORD Reserved)=RegDeleteKeyExW;

LONG WINAPI HookRegDeleteKeyA(  HKEY hKey, LPCSTR lpSubKey){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<RegDeleteKeyA>,func_params=<hKey|"<<hKey<<",lpSubKey|"<<(lpSubKey==NULL?"NULL":lpSubKey)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealRegDeleteKeyA(hKey,lpSubKey);
}
//static LONG (WINAPI *RealRegDeleteKeyA)( HKEY hKey, LPCSTR lpSubKey)=RegDeleteKeyA;
LONG WINAPI HookRegDeleteKeyW(  HKEY hKey, LPCWSTR lpSubKey){
	stringstream logstream;
	logstream.clear();
	logstream<<hostname<<" "<<spy<<" "<<LogTime()<<"account_name="<<"<"<<strBuffer<<">,proc_id=<"<<_getpid()<<">,proc_name=<"<<ProcessName<<">,proc_thread_id=<"<<GetCurrentThreadId()<<">,proc_img_path=<"<<GetProcessPath()<<">,proc_func_name=<RegDeleteKeyW>,func_params=<hKey|"<<hKey<<",lpSubKey|"<<(lpSubKey==NULL?L"NULL":lpSubKey)<<">";

	string s,sm;
	sm="";
	sm=logstream.str();
	sm=sm+"\n\0";
	ofstream f(log_path,ios::app);
	f<<sm;
	f.close();
	sm="";
	logstream.clear();
	//MoveLog();
	//ReleaseMutex(hMutex);
	return RealRegDeleteKeyW(hKey,lpSubKey);
}
//static LONG (WINAPI *RealRegDeleteKeyW)( HKEY hKey, LPCWSTR lpSubKey)=RegDeleteKeyW;


extern "C" __declspec(dllexport) void DummyFunc(void)
{
	return;
}

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  dwReason,
                       LPVOID lpReserved
					 )
{
	//Realsend=DetourFindFunction("Ws2_32.dll","send");
	// install the hook(s)
	/*
	hMutex=OpenMutexA(MUTEX_ALL_ACCESS, false, "mutex");
	if (hMutex==NULL)
	{
		hMutex=CreateMutexA(NULL,FALSE,"mutex");
		ftest<<"create"<<endl;
	}else{
		ftest<<"open"<<endl;
	}
	*/
	/*
	if(s.compare("D:\\Program Files (x86)\\Tencent\\QQ\\bin\\QQ.exe")==0){
		ftest<<"create"<<endl;
		hMutex=CreateMutexA(NULL,TRUE,"mutex");
	}else{
		hMutex=OpenMutexA(MUTEX_ALL_ACCESS, false, "mutex");
		ftest<<"open"<<endl;
	}
	*/
	
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		//ofstream f(log_path,ios::app);
		//f.close();
		DWORD dwSize = 256;
		int len=200;
		GetUserNameA(strBuffer,&dwSize);//获取用户名
		WSAData wsaData;
		WSAStartup(MAKEWORD(1,1), &wsaData); 
		gethostname(hostname,128);//获取主机名
		GetProcessName(ProcessName,&len);//获取进程名
		cout<<ProcessName<<endl;
		cout<<hostname<<endl;
		cout<<strBuffer<<endl;
		//ofstream ftest("C:\\Log\\test.txt",ios::app);
	    
		char windire[100] ={0};  
		GetSystemDirectoryA(windire, 100 );
		SHGetSpecialFolderPathA(NULL,windire,CSIDL_PROGRAM_FILES,FALSE);
		//wprintf(L"%s",windire);
		char configpath[1000]={0};
		sprintf_s(configpath,"%s\\UserMonitor\\bin\\config.xml",windire);
		//sprintf_s(log_path,"%s\\UserMonitor\\bin\\Log.txt",windire);
		//printf(L"%s",configpath);
		
	TiXmlDocument doc;
	if(!doc.LoadFile(configpath)) 
	{
		//ftest<<doc.ErrorDesc()<<endl;
	}

	memset(api,0,200*sizeof(api[0]));
	TiXmlElement* root = doc.FirstChildElement();
	if(root == NULL)
	{
		//ftest<< "Failed to load file: No root element."<<endl;
		doc.Clear();
	}
    int count=0;
	string s=GetProcessPath();
	for(TiXmlElement* elem = root->FirstChildElement(); elem != NULL; elem = elem->NextSiblingElement())
	{
		//cout<<elem->Attribute("name")<<endl;
		TiXmlElement* e1=elem->FirstChildElement("isMonitored");
		//ftest<<atoi(e1->FirstChild()->ToText()->Value())<<endl;
		api[count]=atoi(e1->FirstChild()->ToText()->Value());
		
		for(TiXmlElement* elem1 = e1->NextSiblingElement();elem1 != NULL; elem1 = elem1->NextSiblingElement())
		{
			if(strcmp(elem1->FirstChild()->ToText()->Value(),s.c_str())==0) 
			{
				api[count]=0;
			}
			//获取到的进程的路径格式是：F:\Program Files\AnyDesk\AnyDesk.exe  单斜杆
		}
		
		count++;
		}
		//f1<<GetProcessPath()<<endl;
		//Begin a new transaction for attaching or detaching detours.
	
	/*
		for(int i=1;i<100;i++){
			api[i]=0;
		}
		api[82]=1;
	*/	
		DisableThreadLibraryCalls(hModule);
		int mydetour=0;
		
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());

		
		//文件相关API
		mydetour=(api[0]==1)?DetourAttach(&(PVOID&)RealCreateFileA,HookCreateFileA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[1]==1)?DetourAttach(&(PVOID&)RealMoveFileA,HookMoveFileA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[2]==1)?DetourAttach(&(PVOID&)RealCopyFileA,HookCopyFileA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[3]==1)?DetourAttach(&(PVOID&)RealDeleteFileA, HookDeleteFileA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());		
		if (h_gdi32!=NULL)//DetourAttach的前提是能获得函数所在的DLL才能获得函数的地址
		{
			//f1<<bitblt_addr<<endl;
			mydetour=(api[4]==1)?DetourAttach(&(PVOID&)RealBitBlt,HookBitBlt):0;//将BitBlt进行Attach的话出问题，函数地址没问题，当时总是报HookBitBlt的return的函数有问题
		}
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if (h_crypt32!=NULL)
		{
			mydetour=(api[5]==1)?DetourAttach(&(PVOID&)RealCertOpenSystemStoreA,HookCertOpenSystemStoreA):0;
		}
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if (h_ole32!=NULL)
		{
			mydetour=(api[6]==1)?DetourAttach(&(PVOID&)RealCoCreateInstance,HookCoCreateInstance):0;
		}
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[7]==1)?DetourAttach(&(PVOID&)RealCreateMutexA,HookCreateMutexA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[8]==1)?DetourAttach(&(PVOID&)RealCreateFileMapping,HookCreateFileMapping):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if (h_advapi32!=NULL)
		{
			mydetour=(api[9]==1)?DetourAttach(&(PVOID&)RealCryptAcquireContext,HookCryptAcquireContext):0;
		}
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[10]==1)?DetourAttach(&(PVOID&)RealReadFile,HookReadFile):0;//这个函数调用过于频繁，导致日志量太大
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[11]==1)?DetourAttach(&(PVOID&)RealDeviceIoControl,HookDeviceIoControl):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[12]==1)?DetourAttach(&(PVOID&)RealFindFirstFileA,HookFindFirstFileA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[13]==1)?DetourAttach(&(PVOID&)RealFindNextFileA,HookFindNextFileA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[14]==1)?DetourAttach(&(PVOID&)RealFindResourceA,HookFindResourceA):0;//XP下会崩溃
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[15]==1)?DetourAttach(&(PVOID&)RealFindWindowA,HookFindWindowA):0;//XP下会崩溃
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if (h_wininet!=NULL)
		{
			mydetour=(api[16]==1)?DetourAttach(&(PVOID&)RealFtpPutFileA,HookFtpPutFileA):0;
		}
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[17]==1)?DetourAttach(&(PVOID&)RealGetAsyncKeyState,HookGetAsyncKeyState):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[18]==1)?DetourAttach(&(PVOID&)RealGetDC,HookGetDC):0;//能Hook，但是会崩溃
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[19]==1)?DetourAttach(&(PVOID&)RealGetForegroundWindow,HookGetForegroundWindow):0;//日志量太大
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[20]==1)?DetourAttach(&(PVOID&)RealGetKeyState,HookGetKeyState):0;//输出日志量太大
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[21]==1)?DetourAttach(&(PVOID&)RealGetTempPath,HookGetTempPath):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[22]==1)?DetourAttach(&(PVOID&)RealGetWindowsDirectoryA,HookGetWindowsDirectoryA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[23]==1)?DetourAttach(&(PVOID&)RealMapViewOfFile,HookMapViewOfFile):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[24]==1)?DetourAttach(&(PVOID&)RealMapVirtualKeyA,HookMapVirtualKeyA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[25]==1)?DetourAttach(&(PVOID&)RealOpenFile,HookOpenFile):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[26]==1)?DetourAttach(&(PVOID&)RealOpenMutexA,HookOpenMutexA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[27]==1)?DetourAttach(&(PVOID&)RealOpenSCManagerA,HookOpenSCManagerA):0;//winlogon崩溃
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[28]==1)?DetourAttach(&(PVOID&)RealSetFileTime,HookSetFileTime):0;
		DetourTransactionCommit();
		
        
		//进程相关API
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[29]==1)?DetourAttach(&(PVOID&)RealAdjustTokenPrivileges,HookAdjustTokenPrivileges):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[30]==1)?DetourAttach(&(PVOID&)RealAttachThreadInput,HookAttachThreadInput):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[31]==1)?DetourAttach(&(PVOID&)RealCallNextHookEx,HookCallNextHookEx):0;//日志量太大
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[32]==1)?DetourAttach(&(PVOID&)RealCheckRemoteDebuggerPresent,HookCheckRemoteDebuggerPresent):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[33]==1)?DetourAttach(&(PVOID&)RealControlService,HookControlService):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[34]==1)?DetourAttach(&(PVOID&)RealCreateProcessA,HookCreateProcessA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[35]==1)?DetourAttach(&(PVOID&)RealCreateRemoteThread,HookCreateRemoteThread):0;//可能有问题
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[36]==1)?DetourAttach(&(PVOID&)RealCreateServiceA,HookCreateServiceA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[37]==1)?DetourAttach(&(PVOID&)RealCreateToolhelp32Snapshot,HookCreateToolhelp32Snapshot):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[38]==1)?DetourAttach(&(PVOID&)RealEnumProcesses,HookEnumProcesses):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[39]==1)?DetourAttach(&(PVOID&)RealEnumProcessModules,HookEnumProcessModules):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[40]==1)?DetourAttach(&(PVOID&)RealGetModuleFileNameExA,HookGetModuleFileNameExA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[41]==1)?DetourAttach(&(PVOID&)RealGetModuleHandleA,HookGetModuleHandleA):0;//XP下崩溃
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[42]==1)?DetourAttach(&(PVOID&)RealGetProcAddress,HookGetProcAddress):0;//日志量太大，打印参数有一些问题，为了稳定性不打印参数
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[43]==1)?DetourAttach(&(PVOID&)RealGetStartupInfoA,HookGetStartupInfoA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[44]==1)?DetourAttach(&(PVOID&)RealGetSystemDefaultLangID,HookGetSystemDefaultLangID):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[45]==1)?DetourAttach(&(PVOID&)RealGetThreadContext,HookGetThreadContext):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[46]==1)?DetourAttach(&(PVOID&)RealGetTickCount,HookGetTickCount):0;//这个函数Hook不到，dll导出表显示它有两个参数，msdn说它有一个
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[47]==1)?DetourAttach(&(PVOID&)RealGetVersionExA,HookGetVersionExA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[48]==1)?DetourAttach(&(PVOID&)RealIsDebuggerPresent,HookIsDebuggerPresent):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[49]==1)?DetourAttach(&(PVOID&)RealLoadLibraryA,HookLoadLibraryA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[50]==1)?DetourAttach(&(PVOID&)RealLoadResource,HookLoadResource):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		DetourAttach(&(PVOID&)RealModule32FirstW,HookModule32FirstW);
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		DetourAttach(&(PVOID&)RealModule32NextW,HookModule32NextW);
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[53]==1)?DetourAttach(&(PVOID&)RealOpenProcess,HookOpenProcess):0;//日志量太大
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[54]==1)?DetourAttach(&(PVOID&)RealOutputDebugStringA,HookOutputDebugStringA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[55]==1)?DetourAttach(&(PVOID&)RealPeekNamedPipe,HookPeekNamedPipe):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[56]==1)?DetourAttach(&(PVOID&)RealProcess32First,HookProcess32First):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[57]==1)?DetourAttach(&(PVOID&)RealProcess32Next,HookProcess32Next):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[58]==1)?DetourAttach(&(PVOID&)RealQueryPerformanceCounter,HookQueryPerformanceCounter):0;//日志量太大
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[59]==1)?DetourAttach(&(PVOID&)RealQueueUserAPC,HookQueueUserAPC):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[60]==1)?DetourAttach(&(PVOID&)RealReadProcessMemory,HookReadProcessMemory):0;//XP下会奔溃
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[61]==1)?DetourAttach(&(PVOID&)RealResumeThread,HookResumeThread):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[62]==1)?DetourAttach(&(PVOID&)RealSetThreadContext,HookSetThreadContext):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[63]==1)?DetourAttach(&(PVOID&)RealSetWindowsHookExA,HookSetWindowsHookExA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[64]==1)?DetourAttach(&(PVOID&)RealShellExecuteA,HookShellExecuteA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[65]==1)?DetourAttach(&(PVOID&)RealStartServiceCtrlDispatcherA,HookStartServiceCtrlDispatcherA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[66]==1)?DetourAttach(&(PVOID&)RealSuspendThread,HookSuspendThread):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[67]==1)?DetourAttach(&(PVOID&)Realsystem,Hooksystem):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[68]==1)?DetourAttach(&(PVOID&)RealThread32First,HookThread32First):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[69]==1)?DetourAttach(&(PVOID&)RealThread32Next,HookThread32Next):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[70]==1)?DetourAttach(&(PVOID&)RealToolhelp32ReadProcessMemory,HookToolhelp32ReadProcessMemory):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[71]==1)?DetourAttach(&(PVOID&)RealVirtualAllocEx,HookVirtualAllocEx):0;//XP下会崩溃
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[72]==1)?DetourAttach(&(PVOID&)RealVirtualProtectEx,HookVirtualProtectEx):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[73]==1)?DetourAttach(&(PVOID&)RealWinExec,HookWinExec):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[74]==1)?DetourAttach(&(PVOID&)RealWriteProcessMemory,HookWriteProcessMemory):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[75]==1)?DetourAttach(&(PVOID&)RealRegisterHotKey,HookRegisterHotKey):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[76]==1)?DetourAttach(&(PVOID&)RealCreateProcessW, HookCreateProcessW):0;
		DetourTransactionCommit();
		
		//注册表相关API
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[77]==1)?DetourAttach(&(PVOID&)RealRegOpenKeyA,HookRegOpenKeyA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[78]==1)?DetourAttach(&(PVOID&)RealRegOpenKeyEx,HookRegOpenKeyEx):0;
		DetourTransactionCommit();
		
		
		//网络相关API
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(Realaccept!=NULL) mydetour=(api[79]==1)?DetourAttach(&(PVOID&)Realaccept,Hookaccept):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(Realsend!=NULL) mydetour=(api[80]==1)?DetourAttach(&(PVOID&)Realsend,Hooksend):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(Realbind!=NULL) mydetour=(api[81]==1)?DetourAttach(&(PVOID&)Realbind,Hookbind):0;//XP下崩溃
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(Realconnect!=NULL) mydetour=(api[82]==1)?DetourAttach(&(PVOID&)Realconnect,Hookconnect):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[83]==1)?DetourAttach(&(PVOID&)RealConnectNamedPipe,HookConnectNamedPipe):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealGetAdaptersInfo!=NULL) mydetour=(api[84]==1)?DetourAttach(&(PVOID&)RealGetAdaptersInfo,HookGetAdaptersInfo):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(Realgethostbyname!=NULL) mydetour=(api[85]==1)?DetourAttach(&(PVOID&)Realgethostbyname,Hookgethostbyname):0;//XP下崩溃，这个API只支持Vista或者8.1以上的版本
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(Realgethostname!=NULL) mydetour=(api[86]==1)?DetourAttach(&(PVOID&)Realgethostname,Hookgethostname):0;//XP下崩溃，这个API只支持Vista或者8.1以上的版本
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(Realinet_addr!=NULL) mydetour=(api[87]==1)?DetourAttach(&(PVOID&)Realinet_addr,Hookinet_addr):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealInternetOpenA!=NULL) mydetour=(api[88]==1)?DetourAttach(&(PVOID&)RealInternetOpenA,HookInternetOpenA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealInternetOpenUrlA!=NULL) mydetour=(api[89]==1)?DetourAttach(&(PVOID&)RealInternetOpenUrlA,HookInternetOpenUrlA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealInternetReadFile!=NULL) mydetour=(api[90]==1)?DetourAttach(&(PVOID&)RealInternetReadFile,HookInternetReadFile):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealInternetWriteFile!=NULL) mydetour=(api[91]==1)?DetourAttach(&(PVOID&)RealInternetWriteFile,HookInternetWriteFile):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealNetShareEnum!=NULL) mydetour=(api[92]==1)?DetourAttach(&(PVOID&)RealNetShareEnum,HookNetShareEnum):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(Realrecv!=NULL) mydetour=(api[93]==1)?DetourAttach(&(PVOID&)Realrecv,Hookrecv):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealURLDownloadToFileA!=NULL) mydetour=(api[94]==1)?DetourAttach(&(PVOID&)RealURLDownloadToFileA,HookURLDownloadToFileA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealWSAStartup!=NULL) mydetour=(api[95]==1)?DetourAttach(&(PVOID&)RealWSAStartup,HookWSAStartup):0;
		DetourTransactionCommit();

		//by zhangyunan.
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealCreateFileW!=NULL)mydetour=(api[96]==1)?DetourAttach(&(PVOID&)RealCreateFileW,HookCreateFileW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealMoveFileW!=NULL)mydetour=(api[97]==1)?DetourAttach(&(PVOID&)RealMoveFileW,HookMoveFileW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealCopyFileW!=NULL)mydetour=(api[98]==1)?DetourAttach(&(PVOID&)RealCopyFileW,HookCopyFileW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealDeleteFileW!=NULL)mydetour=(api[99]==1)?DetourAttach(&(PVOID&)RealDeleteFileW,HookDeleteFileW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealFindFirstFileW!=NULL)mydetour=(api[100]==1)?DetourAttach(&(PVOID&)RealFindFirstFileW,HookFindFirstFileW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealFindNextFileW!=NULL)mydetour=(api[101]==1)?DetourAttach(&(PVOID&)RealFindNextFileW,HookFindNextFileW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealCertOpenSystemStoreW!=NULL)mydetour=(api[102]==1)?DetourAttach(&(PVOID&)RealCertOpenSystemStoreW,HookCertOpenSystemStoreW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealCreateMutexW!=NULL)mydetour=(api[103]==1)?DetourAttach(&(PVOID&)RealCreateMutexW,HookCreateMutexW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealFindResourceW!=NULL)mydetour=(api[104]==1)?DetourAttach(&(PVOID&)RealFindResourceW,HookFindResourceW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealFindWindowW!=NULL)mydetour=(api[105]==1)?DetourAttach(&(PVOID&)RealFindWindowW,HookFindWindowW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealGetWindowsDirectoryW!=NULL)mydetour=(api[106]==1)?DetourAttach(&(PVOID&)RealGetWindowsDirectoryW,HookGetWindowsDirectoryW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealMapVirtualKeyW!=NULL)mydetour=(api[107]==1)?DetourAttach(&(PVOID&)RealMapVirtualKeyW,HookMapVirtualKeyW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealOpenMutexW!=NULL)mydetour=(api[108]==1)?DetourAttach(&(PVOID&)RealOpenMutexW,HookOpenMutexW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealOpenSCManagerW!=NULL)mydetour=(api[109]==1)?DetourAttach(&(PVOID&)RealOpenSCManagerW,HookOpenSCManagerW):0;
		DetourTransactionCommit();

		//DetourTransactionBegin();
		//DetourUpdateThread(GetCurrentThread());
		//if(RealCreateProcessW!=NULL)mydetour=(api[110]==1)?DetourAttach(&(PVOID&)RealCreateProcessW,HookCreateProcessW):0;
		//DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealCreateServiceW!=NULL)mydetour=(api[111]==1)?DetourAttach(&(PVOID&)RealCreateServiceW,HookCreateServiceW):0;
		DetourTransactionCommit();

		//DetourTransactionBegin();
		//DetourUpdateThread(GetCurrentThread());
		//mydetour=(api[112]==1)?DetourAttach(&(PVOID&)RealGetModuleFileNameExW,HookGetModuleFileNameExW):0;
		//DetourTransactionCommit();
		
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealGetModuleHandleW!=NULL)mydetour=(api[113]==1)?DetourAttach(&(PVOID&)RealGetModuleHandleW,HookGetModuleHandleW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealGetStartupInfoW!=NULL)mydetour=(api[114]==1)?DetourAttach(&(PVOID&)RealGetStartupInfoW,HookGetStartupInfoW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealGetVersionExW!=NULL)mydetour=(api[115]==1)?DetourAttach(&(PVOID&)RealGetVersionExW,HookGetVersionExW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealLoadLibraryW!=NULL)mydetour=(api[116]==1)?DetourAttach(&(PVOID&)RealLoadLibraryW,HookLoadLibraryW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealOutputDebugStringW!=NULL)mydetour=(api[117]==1)?DetourAttach(&(PVOID&)RealOutputDebugStringW,HookOutputDebugStringW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealSetWindowsHookExW!=NULL)mydetour=(api[118]==1)?DetourAttach(&(PVOID&)RealSetWindowsHookExW,HookSetWindowsHookExW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[119]==1)?DetourAttach(&(PVOID&)RealShellExecuteW,HookShellExecuteW):0;
		//if(RealShellExecuteW!=NULL)mydetour=(api[119]==1)?DetourAttach(&(PVOID&)RealShellExecuteW,HookShellExecuteW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[120]==1)?DetourAttach(&(PVOID&)RealStartServiceCtrlDispatcherW,HookStartServiceCtrlDispatcherW):0;
		//if(RealStartServiceCtrlDispatcherW!=NULL)mydetour=(api[120]==1)?DetourAttach(&(PVOID&)RealStartServiceCtrlDispatcherW,HookStartServiceCtrlDispatcherW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealRegOpenKeyW!=NULL)mydetour=(api[121]==1)?DetourAttach(&(PVOID&)RealRegOpenKeyW,HookRegOpenKeyW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealInternetOpenW!=NULL)mydetour=(api[122]==1)?DetourAttach(&(PVOID&)RealInternetOpenW,HookInternetOpenW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealInternetOpenUrlW!=NULL)mydetour=(api[123]==1)?DetourAttach(&(PVOID&)RealInternetOpenUrlW,HookInternetOpenUrlW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealURLDownloadToFileW!=NULL)mydetour=(api[124]==1)?DetourAttach(&(PVOID&)RealURLDownloadToFileW,HookURLDownloadToFileW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealFtpPutFileW!=NULL)mydetour=(api[125]==1)?DetourAttach(&(PVOID&)RealFtpPutFileW,HookFtpPutFileW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[126]==1)?DetourAttach(&(PVOID&)RealModule32First,HookModule32First):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[127]==1)?DetourAttach(&(PVOID&)RealModule32Next,HookModule32Next):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealRegCreateKeyExA!=NULL)mydetour=(api[128]==1)?DetourAttach(&(PVOID&)RealRegCreateKeyExA,HookRegCreateKeyExA):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealRegCreateKeyExW!=NULL)mydetour=(api[129]==1)?DetourAttach(&(PVOID&)RealRegCreateKeyExW,HookRegCreateKeyExW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[130]==1)?DetourAttach(&(PVOID&)RealRegCreateKeyA,HookRegCreateKeyA):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[131]==1)?DetourAttach(&(PVOID&)RealRegCreateKeyW,HookRegCreateKeyW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealRegQueryValueExA!=NULL)mydetour=(api[132]==1)?DetourAttach(&(PVOID&)RealRegQueryValueExA,HookRegQueryValueExA):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealRegQueryValueExW!=NULL)mydetour=(api[133]==1)?DetourAttach(&(PVOID&)RealRegQueryValueExW,HookRegQueryValueExW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[134]==1)?DetourAttach(&(PVOID&)RealRegQueryValueA,HookRegQueryValueA):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[135]==1)?DetourAttach(&(PVOID&)RealRegQueryValueW,HookRegQueryValueW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealRegSetValueExA!=NULL)mydetour=(api[136]==1)?DetourAttach(&(PVOID&)RealRegSetValueExA,HookRegSetValueExA):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealRegSetValueExW!=NULL)mydetour=(api[137]==1)?DetourAttach(&(PVOID&)RealRegSetValueExW,HookRegSetValueExW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealRegSetValueA!=NULL)mydetour=(api[138]==1)?DetourAttach(&(PVOID&)RealRegSetValueA,HookRegSetValueA):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealRegSetValueW!=NULL)mydetour=(api[139]==1)?DetourAttach(&(PVOID&)RealRegSetValueW,HookRegSetValueW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealRegDeleteKeyExA!=NULL)mydetour=(api[140]==1)?DetourAttach(&(PVOID&)RealRegDeleteKeyExA,HookRegDeleteKeyExA):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealRegDeleteKeyExW!=NULL)mydetour=(api[141]==1)?DetourAttach(&(PVOID&)RealRegDeleteKeyExW,HookRegDeleteKeyExW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealRegDeleteKeyA!=NULL)mydetour=(api[142]==1)?DetourAttach(&(PVOID&)RealRegDeleteKeyA,HookRegDeleteKeyA):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealRegDeleteKeyW!=NULL)mydetour=(api[143]==1)?DetourAttach(&(PVOID&)RealRegDeleteKeyW,HookRegDeleteKeyW):0;
		DetourTransactionCommit();
		
		/*
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealWriteFile!=NULL) mydetour=DetourAttach(&(PVOID&)RealWriteFile,HookWriteFile);
		DetourTransactionCommit();
		*/
	} 
	// uninstall the hook(s)
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		int mydetour=0;
		
		//f.close();
		
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		
		//文件相关API
		mydetour=(api[0]==1)?DetourDetach(&(PVOID&)RealCreateFileA,HookCreateFileA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[1]==1)?DetourDetach(&(PVOID&)RealMoveFileA,HookMoveFileA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[2]==1)?DetourDetach(&(PVOID&)RealCopyFileA,HookCopyFileA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[3]==1)?DetourDetach(&(PVOID&)RealDeleteFileA, HookDeleteFileA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());		
		if (h_gdi32!=NULL)//DetourDetach的前提是能获得函数所在的DLL才能获得函数的地址
		{
			//f1<<bitblt_addr<<endl;
			mydetour=(api[4]==1)?DetourDetach(&(PVOID&)RealBitBlt,HookBitBlt):0;//将BitBlt进行Attach的话出问题，函数地址没问题，当时总是报HookBitBlt的return的函数有问题
		}
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if (h_crypt32!=NULL)
		{
			mydetour=(api[5]==1)?DetourDetach(&(PVOID&)RealCertOpenSystemStoreA,HookCertOpenSystemStoreA):0;
		}
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if (h_ole32!=NULL)
		{
			mydetour=(api[6]==1)?DetourDetach(&(PVOID&)RealCoCreateInstance,HookCoCreateInstance):0;
		}
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[7]==1)?DetourDetach(&(PVOID&)RealCreateMutexA,HookCreateMutexA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[8]==1)?DetourDetach(&(PVOID&)RealCreateFileMapping,HookCreateFileMapping):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if (h_advapi32!=NULL)
		{
			mydetour=(api[9]==1)?DetourDetach(&(PVOID&)RealCryptAcquireContext,HookCryptAcquireContext):0;
		}
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[10]==1)?DetourDetach(&(PVOID&)RealReadFile,HookReadFile):0;//这个函数调用过于频繁，导致日志量太大
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[11]==1)?DetourDetach(&(PVOID&)RealDeviceIoControl,HookDeviceIoControl):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[12]==1)?DetourDetach(&(PVOID&)RealFindFirstFileA,HookFindFirstFileA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[13]==1)?DetourDetach(&(PVOID&)RealFindNextFileA,HookFindNextFileA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[14]==1)?DetourDetach(&(PVOID&)RealFindResourceA,HookFindResourceA):0;//XP下会崩溃
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[15]==1)?DetourDetach(&(PVOID&)RealFindWindowA,HookFindWindowA):0;//XP下会崩溃
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if (h_wininet!=NULL)
		{
			mydetour=(api[16]==1)?DetourDetach(&(PVOID&)RealFtpPutFileA,HookFtpPutFileA):0;
		}
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[17]==1)?DetourDetach(&(PVOID&)RealGetAsyncKeyState,HookGetAsyncKeyState):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[18]==1)?DetourDetach(&(PVOID&)RealGetDC,HookGetDC):0;//能Hook，但是会崩溃
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[19]==1)?DetourDetach(&(PVOID&)RealGetForegroundWindow,HookGetForegroundWindow):0;//日志量太大
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[20]==1)?DetourDetach(&(PVOID&)RealGetKeyState,HookGetKeyState):0;//输出日志量太大
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[21]==1)?DetourDetach(&(PVOID&)RealGetTempPath,HookGetTempPath):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[22]==1)?DetourDetach(&(PVOID&)RealGetWindowsDirectoryA,HookGetWindowsDirectoryA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[23]==1)?DetourDetach(&(PVOID&)RealMapViewOfFile,HookMapViewOfFile):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[24]==1)?DetourDetach(&(PVOID&)RealMapVirtualKeyA,HookMapVirtualKeyA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[25]==1)?DetourDetach(&(PVOID&)RealOpenFile,HookOpenFile):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[26]==1)?DetourDetach(&(PVOID&)RealOpenMutexA,HookOpenMutexA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[27]==1)?DetourDetach(&(PVOID&)RealOpenSCManagerA,HookOpenSCManagerA):0;//winlogon崩溃
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[28]==1)?DetourDetach(&(PVOID&)RealSetFileTime,HookSetFileTime):0;
		DetourTransactionCommit();
		   
		//进程相关API
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[29]==1)?DetourDetach(&(PVOID&)RealAdjustTokenPrivileges,HookAdjustTokenPrivileges):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[30]==1)?DetourDetach(&(PVOID&)RealAttachThreadInput,HookAttachThreadInput):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[31]==1)?DetourDetach(&(PVOID&)RealCallNextHookEx,HookCallNextHookEx):0;//日志量太大
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[32]==1)?DetourDetach(&(PVOID&)RealCheckRemoteDebuggerPresent,HookCheckRemoteDebuggerPresent):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[33]==1)?DetourDetach(&(PVOID&)RealControlService,HookControlService):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[34]==1)?DetourDetach(&(PVOID&)RealCreateProcessA,HookCreateProcessA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[35]==1)?DetourDetach(&(PVOID&)RealCreateRemoteThread,HookCreateRemoteThread):0;//可能有问题
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[36]==1)?DetourDetach(&(PVOID&)RealCreateServiceA,HookCreateServiceA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[37]==1)?DetourDetach(&(PVOID&)RealCreateToolhelp32Snapshot,HookCreateToolhelp32Snapshot):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[38]==1)?DetourDetach(&(PVOID&)RealEnumProcesses,HookEnumProcesses):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[39]==1)?DetourDetach(&(PVOID&)RealEnumProcessModules,HookEnumProcessModules):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[40]==1)?DetourDetach(&(PVOID&)RealGetModuleFileNameExA,HookGetModuleFileNameExA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[41]==1)?DetourDetach(&(PVOID&)RealGetModuleHandleA,HookGetModuleHandleA):0;//XP下崩溃
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[42]==1)?DetourDetach(&(PVOID&)RealGetProcAddress,HookGetProcAddress):0;//日志量太大，打印参数有一些问题，为了稳定性不打印参数
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[43]==1)?DetourDetach(&(PVOID&)RealGetStartupInfoA,HookGetStartupInfoA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[44]==1)?DetourDetach(&(PVOID&)RealGetSystemDefaultLangID,HookGetSystemDefaultLangID):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[45]==1)?DetourDetach(&(PVOID&)RealGetThreadContext,HookGetThreadContext):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[46]==1)?DetourDetach(&(PVOID&)RealGetTickCount,HookGetTickCount):0;//这个函数Hook不到，dll导出表显示它有两个参数，msdn说它有一个
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[47]==1)?DetourDetach(&(PVOID&)RealGetVersionExA,HookGetVersionExA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[48]==1)?DetourDetach(&(PVOID&)RealIsDebuggerPresent,HookIsDebuggerPresent):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[49]==1)?DetourDetach(&(PVOID&)RealLoadLibraryA,HookLoadLibraryA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[50]==1)?DetourDetach(&(PVOID&)RealLoadResource,HookLoadResource):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		DetourDetach(&(PVOID&)RealModule32FirstW,HookModule32FirstW);
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		DetourDetach(&(PVOID&)RealModule32NextW,HookModule32NextW);
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[53]==1)?DetourDetach(&(PVOID&)RealOpenProcess,HookOpenProcess):0;//日志量太大
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[54]==1)?DetourDetach(&(PVOID&)RealOutputDebugStringA,HookOutputDebugStringA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[55]==1)?DetourDetach(&(PVOID&)RealPeekNamedPipe,HookPeekNamedPipe):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[56]==1)?DetourDetach(&(PVOID&)RealProcess32First,HookProcess32First):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[57]==1)?DetourDetach(&(PVOID&)RealProcess32Next,HookProcess32Next):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[58]==1)?DetourDetach(&(PVOID&)RealQueryPerformanceCounter,HookQueryPerformanceCounter):0;//日志量太大
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[59]==1)?DetourDetach(&(PVOID&)RealQueueUserAPC,HookQueueUserAPC):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[60]==1)?DetourDetach(&(PVOID&)RealReadProcessMemory,HookReadProcessMemory):0;//XP下会奔溃
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[61]==1)?DetourDetach(&(PVOID&)RealResumeThread,HookResumeThread):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[62]==1)?DetourDetach(&(PVOID&)RealSetThreadContext,HookSetThreadContext):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[63]==1)?DetourDetach(&(PVOID&)RealSetWindowsHookExA,HookSetWindowsHookExA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[64]==1)?DetourDetach(&(PVOID&)RealShellExecuteA,HookShellExecuteA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[65]==1)?DetourDetach(&(PVOID&)RealStartServiceCtrlDispatcherA,HookStartServiceCtrlDispatcherA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[66]==1)?DetourDetach(&(PVOID&)RealSuspendThread,HookSuspendThread):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[67]==1)?DetourDetach(&(PVOID&)Realsystem,Hooksystem):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[68]==1)?DetourDetach(&(PVOID&)RealThread32First,HookThread32First):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[69]==1)?DetourDetach(&(PVOID&)RealThread32Next,HookThread32Next):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[70]==1)?DetourDetach(&(PVOID&)RealToolhelp32ReadProcessMemory,HookToolhelp32ReadProcessMemory):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[71]==1)?DetourDetach(&(PVOID&)RealVirtualAllocEx,HookVirtualAllocEx):0;//XP下会崩溃
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[72]==1)?DetourDetach(&(PVOID&)RealVirtualProtectEx,HookVirtualProtectEx):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[73]==1)?DetourDetach(&(PVOID&)RealWinExec,HookWinExec):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[74]==1)?DetourDetach(&(PVOID&)RealWriteProcessMemory,HookWriteProcessMemory):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[75]==1)?DetourDetach(&(PVOID&)RealRegisterHotKey,HookRegisterHotKey):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[76]==1)?DetourDetach(&(PVOID&)RealCreateProcessW, HookCreateProcessW):0;
		DetourTransactionCommit();
		
		
		//注册表相关API
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[77]==1)?DetourDetach(&(PVOID&)RealRegOpenKeyA,HookRegOpenKeyA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[78]==1)?DetourDetach(&(PVOID&)RealRegOpenKeyEx,HookRegOpenKeyEx):0;
		DetourTransactionCommit();
		
		
		//网络相关API
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(Realaccept!=NULL) mydetour=(api[79]==1)?DetourDetach(&(PVOID&)Realaccept,Hookaccept):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(Realsend!=NULL) mydetour=(api[80]==1)?DetourDetach(&(PVOID&)Realsend,Hooksend):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(Realbind!=NULL) mydetour=(api[81]==1)?DetourDetach(&(PVOID&)Realbind,Hookbind):0;//XP下崩溃
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(Realconnect!=NULL) mydetour=(api[82]==1)?DetourDetach(&(PVOID&)Realconnect,Hookconnect):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[83]==1)?DetourDetach(&(PVOID&)RealConnectNamedPipe,HookConnectNamedPipe):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealGetAdaptersInfo!=NULL) mydetour=(api[84]==1)?DetourDetach(&(PVOID&)RealGetAdaptersInfo,HookGetAdaptersInfo):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(Realgethostbyname!=NULL) mydetour=(api[85]==1)?DetourDetach(&(PVOID&)Realgethostbyname,Hookgethostbyname):0;//XP下崩溃，这个API只支持Vista或者8.1以上的版本
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(Realgethostname!=NULL) mydetour=(api[86]==1)?DetourDetach(&(PVOID&)Realgethostname,Hookgethostname):0;//XP下崩溃，这个API只支持Vista或者8.1以上的版本
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(Realinet_addr!=NULL) mydetour=(api[87]==1)?DetourDetach(&(PVOID&)Realinet_addr,Hookinet_addr):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealInternetOpenA!=NULL) mydetour=(api[88]==1)?DetourDetach(&(PVOID&)RealInternetOpenA,HookInternetOpenA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealInternetOpenUrlA!=NULL) mydetour=(api[89]==1)?DetourDetach(&(PVOID&)RealInternetOpenUrlA,HookInternetOpenUrlA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealInternetReadFile!=NULL) mydetour=(api[90]==1)?DetourDetach(&(PVOID&)RealInternetReadFile,HookInternetReadFile):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealInternetWriteFile!=NULL) mydetour=(api[91]==1)?DetourDetach(&(PVOID&)RealInternetWriteFile,HookInternetWriteFile):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealNetShareEnum!=NULL) mydetour=(api[92]==1)?DetourDetach(&(PVOID&)RealNetShareEnum,HookNetShareEnum):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(Realrecv!=NULL) mydetour=(api[93]==1)?DetourDetach(&(PVOID&)Realrecv,Hookrecv):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealURLDownloadToFileA!=NULL) mydetour=(api[94]==1)?DetourDetach(&(PVOID&)RealURLDownloadToFileA,HookURLDownloadToFileA):0;
		DetourTransactionCommit();
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealWSAStartup!=NULL) mydetour=(api[95]==1)?DetourDetach(&(PVOID&)RealWSAStartup,HookWSAStartup):0;
		DetourTransactionCommit();
		
		//by zhangyunan
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[96]==1)?DetourDetach(&(PVOID&)RealCreateFileW,HookCreateFileW):0;
		DetourTransactionCommit();
		
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[97]==1)?DetourDetach(&(PVOID&)RealMoveFileW,HookMoveFileW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[98]==1)?DetourDetach(&(PVOID&)RealCopyFileW,HookCopyFileW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[99]==1)?DetourDetach(&(PVOID&)RealDeleteFileW,HookDeleteFileW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[100]==1)?DetourDetach(&(PVOID&)RealFindFirstFileW,HookFindFirstFileW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[101]==1)?DetourDetach(&(PVOID&)RealFindNextFileW,HookFindNextFileW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[102]==1)?DetourDetach(&(PVOID&)RealCertOpenSystemStoreW,HookCertOpenSystemStoreW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[103]==1)?DetourDetach(&(PVOID&)RealCreateMutexW,HookCreateMutexW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[104]==1)?DetourDetach(&(PVOID&)RealFindResourceW,HookFindResourceW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[105]==1)?DetourDetach(&(PVOID&)RealFindWindowW,HookFindWindowW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[106]==1)?DetourDetach(&(PVOID&)RealGetWindowsDirectoryW,HookGetWindowsDirectoryW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[107]==1)?DetourDetach(&(PVOID&)RealMapVirtualKeyW,HookMapVirtualKeyW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[108]==1)?DetourDetach(&(PVOID&)RealOpenMutexW,HookOpenMutexW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[109]==1)?DetourDetach(&(PVOID&)RealOpenSCManagerW,HookOpenSCManagerW):0;
		DetourTransactionCommit();

		//DetourTransactionBegin();
		//DetourUpdateThread(GetCurrentThread());
		//mydetour=(api[110]==1)?DetourDetach(&(PVOID&)RealCreateProcessW,HookCreateProcessW):0;
		//DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[111]==1)?DetourDetach(&(PVOID&)RealCreateServiceW,HookCreateServiceW):0;
		DetourTransactionCommit();

		//DetourTransactionBegin();
		//DetourUpdateThread(GetCurrentThread());
		//mydetour=(api[112]==1)?DetourDetach(&(PVOID&)RealGetModuleFileNameExW,HookGetModuleFileNameExW):0;
		//DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[113]==1)?DetourDetach(&(PVOID&)RealGetModuleHandleW,HookGetModuleHandleW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[114]==1)?DetourDetach(&(PVOID&)RealGetStartupInfoW,HookGetStartupInfoW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[115]==1)?DetourDetach(&(PVOID&)RealGetVersionExW,HookGetVersionExW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[116]==1)?DetourDetach(&(PVOID&)RealLoadLibraryW,HookLoadLibraryW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[117]==1)?DetourDetach(&(PVOID&)RealOutputDebugStringW,HookOutputDebugStringW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[118]==1)?DetourDetach(&(PVOID&)RealSetWindowsHookExW,HookSetWindowsHookExW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[119]==1)?DetourDetach(&(PVOID&)RealShellExecuteW,HookShellExecuteW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[120]==1)?DetourDetach(&(PVOID&)RealStartServiceCtrlDispatcherW,HookStartServiceCtrlDispatcherW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[121]==1)?DetourDetach(&(PVOID&)RealRegOpenKeyW,HookRegOpenKeyW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealInternetOpenW!=NULL) mydetour=(api[122]==1)?DetourDetach(&(PVOID&)RealInternetOpenW,HookInternetOpenW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealInternetOpenUrlW!=NULL) mydetour=(api[123]==1)?DetourDetach(&(PVOID&)RealInternetOpenUrlW,HookInternetOpenUrlW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealURLDownloadToFileW!=NULL) mydetour=(api[124]==1)?DetourDetach(&(PVOID&)RealURLDownloadToFileW,HookURLDownloadToFileW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealFtpPutFileW!=NULL) mydetour=(api[125]==1)?DetourDetach(&(PVOID&)RealFtpPutFileW,HookFtpPutFileW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[126]==1)?DetourDetach(&(PVOID&)RealModule32First,HookModule32First):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[127]==1)?DetourDetach(&(PVOID&)RealModule32Next,HookModule32Next):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[128]==1)?DetourDetach(&(PVOID&)RealRegCreateKeyExA,HookRegCreateKeyExA):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[129]==1)?DetourDetach(&(PVOID&)RealRegCreateKeyExW,HookRegCreateKeyExW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[130]==1)?DetourDetach(&(PVOID&)RealRegCreateKeyA,HookRegCreateKeyA):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[131]==1)?DetourDetach(&(PVOID&)RealRegCreateKeyW,HookRegCreateKeyW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[132]==1)?DetourDetach(&(PVOID&)RealRegQueryValueExA,HookRegQueryValueExA):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[133]==1)?DetourDetach(&(PVOID&)RealRegQueryValueExW,HookRegQueryValueExW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[134]==1)?DetourDetach(&(PVOID&)RealRegQueryValueA,HookRegQueryValueA):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[135]==1)?DetourDetach(&(PVOID&)RealRegQueryValueW,HookRegQueryValueW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[136]==1)?DetourDetach(&(PVOID&)RealRegSetValueExA,HookRegSetValueExA):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[137]==1)?DetourDetach(&(PVOID&)RealRegSetValueExW,HookRegSetValueExW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[138]==1)?DetourDetach(&(PVOID&)RealRegSetValueA,HookRegSetValueA):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[139]==1)?DetourDetach(&(PVOID&)RealRegSetValueW,HookRegSetValueW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[140]==1)?DetourDetach(&(PVOID&)RealRegDeleteKeyExA,HookRegDeleteKeyExA):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[141]==1)?DetourDetach(&(PVOID&)RealRegDeleteKeyExW,HookRegDeleteKeyExW):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[142]==1)?DetourDetach(&(PVOID&)RealRegDeleteKeyA,HookRegDeleteKeyA):0;
		DetourTransactionCommit();

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		mydetour=(api[143]==1)?DetourDetach(&(PVOID&)RealRegDeleteKeyW,HookRegDeleteKeyW):0;
		DetourTransactionCommit();
		
		/*
		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		if(RealWriteFile!=NULL) mydetour=DetourDetach(&(PVOID&)RealWriteFile,HookWriteFile);
		DetourTransactionCommit();
		*/
	}
	
	return TRUE;
}

#ifdef _MANAGED
#pragma managed(pop)
#endif


